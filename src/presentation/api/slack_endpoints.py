import json
from datetime import datetime, timezone
from fastapi import APIRouter, Request, HTTPException, Form, Depends
from fastapi.responses import JSONResponse
from typing import Dict, Any, Optional, List
from src.application.services.task_service import TaskApplicationService
from src.application.dto.task_dto import CreateTaskRequestDto, TaskApprovalDto, ReviseTaskRequestDto
from src.infrastructure.slack.slack_service import SlackService, REMINDER_STAGE_LABELS
from src.infrastructure.notion.admin_metrics_service import AdminMetricsNotionService
from src.application.services.task_metrics_service import TaskMetricsApplicationService
from src.infrastructure.notion.dynamic_notion_service import (
    DynamicNotionService,
    REMINDER_STAGE_BEFORE,
    REMINDER_STAGE_DUE,
    REMINDER_STAGE_OVERDUE,
    REMINDER_STAGE_PENDING_APPROVAL,
    EXTENSION_STATUS_PENDING,
    COMPLETION_STATUS_REQUESTED,
    COMPLETION_STATUS_APPROVED,
    TASK_STATUS_PENDING,
    TASK_STATUS_APPROVED,
)
from src.infrastructure.repositories.notion_user_repository_impl import NotionUserRepositoryImpl
from src.infrastructure.repositories.slack_user_repository_impl import SlackUserRepositoryImpl
from src.application.services.user_mapping_service import UserMappingApplicationService
from src.domain.services.user_mapping_domain_service import UserMappingDomainService
from src.infrastructure.repositories.task_repository_impl import InMemoryTaskRepository
from src.infrastructure.repositories.user_repository_impl import InMemoryUserRepository
from src.infrastructure.google.google_calendar_service import GoogleCalendarService
from src.infrastructure.repositories.calendar_task_repository_impl import GoogleCalendarTaskRepository
from src.application.services.calendar_task_service import CalendarTaskApplicationService
from src.services.ai_service import TaskAIService, TaskInfo, AIAnalysisResult
from src.utils.text_converter import convert_rich_text_to_plain_text
from src.domain.value_objects.email import Email
from zoneinfo import ZoneInfo
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    slack_token: str = ""
    slack_bot_token: str = ""
    slack_signing_secret: str = ""
    notion_token: str = ""
    notion_database_id: str = ""
    notion_audit_database_id: str = ""
    mapping_database_id: str = ""
    notion_metrics_database_id: str = ""
    notion_assignee_summary_database_id: str = ""
    gcs_bucket_name: str = ""
    google_application_credentials: str = ""
    service_account_json: str = ""
    env: str = "local"
    gemini_api_key: str = ""
    gemini_timeout_seconds: float = 30.0
    gemini_model: str = "gemini-2.5-flash"
    gemini_history_path: str = ".ai_conversations.json"

    class Config:
        env_file = ".env"

    @property
    def slack_command_name(self) -> str:
        """Áí∞Â¢É„Å´Âøú„Åò„Å¶„Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„ÉâÂêç„ÇíËøî„Åô"""
        if self.env == "production":
            return "/task-request"
        else:
            return "/task-request-dev"

    @property
    def app_name_suffix(self) -> str:
        """Áí∞Â¢É„Å´Âøú„Åò„Å¶„Ç¢„Éó„É™Âêç„ÅÆÊé•Â∞æËæû„ÇíËøî„Åô"""
        if self.env == "production":
            return ""
        else:
            return " (Dev)"


router = APIRouter(prefix="/slack", tags=["slack"])
settings = Settings()
JST = ZoneInfo("Asia/Tokyo")

# „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±„Çí‰∏ÄÊôÇÁöÑ„Å´‰øùÂ≠ò„Åô„ÇãËæûÊõ∏
modal_sessions = {}

print("üöÄ Slack-Notion Task Management System initialized!")
print(f"üåç Environment: {settings.env}")
print(f"üìã Slack Command: {settings.slack_command_name}{settings.app_name_suffix}")
print(f"üìä Notion Database: {settings.notion_database_id}")
if settings.notion_metrics_database_id:
    print(f"üìà Metrics Database: {settings.notion_metrics_database_id}")
if settings.notion_assignee_summary_database_id:
    print(f"üë§ Summary Database: {settings.notion_assignee_summary_database_id}")
print("üîÑ Using dynamic user search (no mapping files)")

# „É™„Éù„Ç∏„Éà„É™„Å®„Çµ„Éº„Éì„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñÔºàDDDÁâàDIÔºâ
task_repository = InMemoryTaskRepository()
user_repository = InMemoryUserRepository()
slack_service = SlackService(settings.slack_token, settings.slack_bot_token, settings.env)

# Êñ∞„Åó„ÅÑDDDÂÆüË£Ö„ÅÆ„Çµ„Éº„Éì„ÇπÂàùÊúüÂåñ
notion_user_repository = NotionUserRepositoryImpl(
    notion_token=settings.notion_token,
    default_database_id=settings.notion_database_id
)
slack_user_repository = SlackUserRepositoryImpl(slack_token=settings.slack_bot_token)
mapping_domain_service = UserMappingDomainService()
user_mapping_service = UserMappingApplicationService(
    notion_user_repository=notion_user_repository,
    slack_user_repository=slack_user_repository,
    mapping_domain_service=mapping_domain_service
)

# ÂãïÁöÑNotion„Çµ„Éº„Éì„ÇπÔºàDDD „Éô„Éº„ÇπÔºâ
notion_service = DynamicNotionService(
    notion_token=settings.notion_token,
    database_id=settings.notion_database_id,
    user_mapping_service=user_mapping_service,
    audit_database_id=settings.notion_audit_database_id,
)
admin_metrics_service = AdminMetricsNotionService(
    notion_token=settings.notion_token,
    metrics_database_id=settings.notion_metrics_database_id,
    summary_database_id=settings.notion_assignee_summary_database_id,
)
task_metrics_service = TaskMetricsApplicationService(admin_metrics_service=admin_metrics_service)
ai_service = (
    TaskAIService(
        settings.gemini_api_key,
        timeout_seconds=settings.gemini_timeout_seconds,
        model_name=settings.gemini_model,
        history_storage_path=settings.gemini_history_path,
    )
    if settings.gemini_api_key
    else None
)

task_service = TaskApplicationService(
    task_repository=task_repository,
    user_repository=user_repository,
    slack_service=slack_service,
    notion_service=notion_service,
    task_metrics_service=task_metrics_service,
)

# Google Calendar „Çµ„Éº„Éì„Çπ„ÅÆÂàùÊúüÂåñÔºà„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºâ
calendar_task_service = None
if settings.service_account_json:
    try:
        google_calendar_service = GoogleCalendarService(
            service_account_json=settings.service_account_json,
            env=settings.env
        )
        calendar_task_repository = GoogleCalendarTaskRepository(google_calendar_service)
        calendar_task_service = CalendarTaskApplicationService(
            calendar_task_repository=calendar_task_repository,
            user_mapping_service=user_mapping_service
        )
        print("‚úÖ Google Calendar integration initialized")
    except Exception as e:
        print(f"‚ö†Ô∏è Google Calendar initialization failed: {e}")
        print("   Calendar integration will be disabled")


@router.post("/cron/run-reminders")
async def run_reminders():
    """Notion„Çø„Çπ„ÇØ„ÅÆ„É™„Éû„Ç§„É≥„Éâ„ÇíÂÆüË°åÔºàCloud SchedulerÁî®Ôºâ"""
    now = datetime.now(timezone.utc)
    try:
        snapshots = await notion_service.fetch_active_tasks()
    except Exception as fetch_error:
        print(f"‚ö†Ô∏è Failed to fetch tasks for reminders: {fetch_error}")
        return {"error": "notion_fetch_failed"}

    email_cache: Dict[str, Optional[str]] = {}
    notifications: List[Dict[str, Any]] = []
    errors: List[str] = []

    metrics_cache = await task_metrics_service.ensure_metrics_for_snapshots(snapshots)

    async def resolve_slack_id(email: Optional[str]) -> Optional[str]:
        if not email:
            return None
        if email in email_cache:
            return email_cache[email]
        try:
            slack_user = await slack_user_repository.find_by_email(Email(email))
            if slack_user:
                slack_id = str(slack_user.user_id)
                email_cache[email] = slack_id
                return slack_id
        except Exception as lookup_error:
            print(f"‚ö†Ô∏è Slack lookup failed for {email}: {lookup_error}")
            errors.append(f"slack_lookup:{email}")
        email_cache[email] = None
        return None

    for snapshot in snapshots:
        try:
            stage = determine_reminder_stage(snapshot, now)

            metrics = metrics_cache.get(snapshot.page_id)

            if stage is None:
                if metrics and metrics.overdue_points and _should_clear_overdue_points(snapshot, now):
                    updated_metrics = await task_metrics_service.update_overdue_points(snapshot.page_id, 0)
                    if updated_metrics:
                        metrics_cache[snapshot.page_id] = updated_metrics
                continue

            if stage == REMINDER_STAGE_PENDING_APPROVAL and metrics and metrics.overdue_points:
                updated_metrics = await task_metrics_service.update_overdue_points(snapshot.page_id, 0)
                if updated_metrics:
                    metrics_cache[snapshot.page_id] = updated_metrics
                    metrics = updated_metrics

            if stage == snapshot.reminder_stage:
                await task_metrics_service.update_reminder_stage(snapshot.page_id, stage, now)
                continue

            assignee_slack_id = await resolve_slack_id(snapshot.assignee_email)
            if not assignee_slack_id:
                errors.append(f"assignee_missing:{snapshot.page_id}")
                continue

            requester_slack_id = await resolve_slack_id(snapshot.requester_email)

            if stage == REMINDER_STAGE_OVERDUE:
                requested_before_due = _requested_on_time(
                    snapshot.completion_requested_at,
                    snapshot.due_date,
                )
                completion_safe = (
                    snapshot.completion_status in {COMPLETION_STATUS_REQUESTED, COMPLETION_STATUS_APPROVED}
                    and requested_before_due
                )
                eligible_for_overdue_points = getattr(snapshot, "status", None) == TASK_STATUS_APPROVED
                target_points = 1 if (eligible_for_overdue_points and not completion_safe) else 0
                current_points = metrics.overdue_points if metrics else 0
                if current_points != target_points:
                    updated_metrics = await task_metrics_service.update_overdue_points(snapshot.page_id, target_points)
                    if updated_metrics:
                        metrics_cache[snapshot.page_id] = updated_metrics
                        metrics = updated_metrics
            else:
                current_points = metrics.overdue_points if metrics else 0
                if current_points and _should_clear_overdue_points(snapshot, now):
                    updated_metrics = await task_metrics_service.update_overdue_points(snapshot.page_id, 0)
                    if updated_metrics:
                        metrics_cache[snapshot.page_id] = updated_metrics
                        metrics = updated_metrics

            await slack_service.send_task_reminder(
                assignee_slack_id=assignee_slack_id,
                snapshot=snapshot,
                stage=stage,
                requester_slack_id=requester_slack_id,
            )

            await notion_service.update_reminder_state(snapshot.page_id, stage, now)
            await task_metrics_service.update_reminder_stage(snapshot.page_id, stage, now)
            snapshot.reminder_stage = stage

            detail = f"{REMINDER_STAGE_LABELS.get(stage, stage)}\nÁ¥çÊúü: {_format_datetime_text(snapshot.due_date)}"
            event_type = "ÊúüÈôêË∂ÖÈÅé" if stage == REMINDER_STAGE_OVERDUE else "„É™„Éû„Ç§„É≥„ÉâÈÄÅ‰ø°"
            await notion_service.record_audit_log(
                task_page_id=snapshot.page_id,
                event_type=event_type,
                detail=detail,
            )

            notifications.append(
                {
                    "page_id": snapshot.page_id,
                    "stage": stage,
                    "assignee_slack_id": assignee_slack_id,
                    "requester_slack_id": requester_slack_id,
                }
            )

        except Exception as reminder_error:
            print(f"‚ö†Ô∏è Reminder processing failed for task {getattr(snapshot, 'page_id', 'unknown')}: {reminder_error}")
            errors.append(f"reminder_error:{getattr(snapshot, 'page_id', 'unknown')}")

    await task_metrics_service.refresh_assignee_summaries()

    return {
        "timestamp": now.isoformat(),
        "checked": len(snapshots),
        "notified": len(notifications),
        "notifications": notifications,
        "errors": errors,
    }


@router.post("/commands")
async def handle_slash_command(request: Request):
    """„Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ„ÅÆ„Éè„É≥„Éâ„É©„Éº"""
    form = await request.form()
    command = form.get("command")
    trigger_id = form.get("trigger_id")
    user_id = form.get("user_id")

    if command == settings.slack_command_name:
        # „Çø„Çπ„ÇØ‰ΩúÊàê„É¢„Éº„ÉÄ„É´„ÇíÈñã„ÅèÔºàÂç≥ÊôÇACK + „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÁ∂öË°åÔºâ
        import asyncio
        asyncio.create_task(slack_service.open_task_modal(trigger_id, user_id))
        return JSONResponse(content={"response_type": "ephemeral", "text": ""})

    return JSONResponse(
        content={"response_type": "ephemeral", "text": "Unknown command"}
    )


@router.post("/interactive")
async def handle_interactive(request: Request):
    """„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÔºà„Éú„Çø„É≥„ÄÅ„É¢„Éº„ÉÄ„É´Ôºâ„ÅÆ„Éè„É≥„Éâ„É©„Éº"""
    form = await request.form()
    payload = json.loads(form.get("payload", "{}"))

    interaction_type = payload.get("type")
    print(f"üîç Interactive payload received: type={interaction_type}")

    if interaction_type == "block_actions":
        # „Éú„Çø„É≥„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂá¶ÁêÜ
        action = payload["actions"][0]
        action_id = action["action_id"]
        task_id = action.get("value", "")
        trigger_id = payload["trigger_id"]
        view = payload.get("view", {})
        view_id = view.get("id")
        user_id = payload.get("user", {}).get("id", "unknown")
        
        print(f"üéØ Block action received: action_id={action_id}, user_id={user_id}")
        print(f"üîç Available actions: {[a.get('action_id') for a in payload.get('actions', [])]}")

        if action_id == "approve_task":
            try:
                # Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫Ôºà3ÁßíÂà∂ÈôêÂõûÈÅøÔºâ
                loading_response = {
                    "response_action": "update",
                    "text": "‚è≥ „Çø„Çπ„ÇØ„ÇíÊâøË™ç‰∏≠...",
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": "‚è≥ *„Çø„Çπ„ÇØ„ÇíÊâøË™ç„Åó„Å¶„ÅÑ„Åæ„Åô...*\n\n„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                            }
                        }
                    ]
                }
                
                # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÊâøË™çÂá¶ÁêÜ„ÇíÂÆüË°å
                import asyncio
                
                async def run_approval():
                    try:
                        dto = TaskApprovalDto(
                            task_id=task_id,
                            action="approve",
                            rejection_reason=None,
                        )
                        approval_result = await task_service.handle_task_approval(dto)
                        print("‚úÖ ÊâøË™çÂá¶ÁêÜÊàêÂäü")

                        # Google Calendar „Å´„Çø„Çπ„ÇØ„ÇíËøΩÂä†Ôºà„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºâ
                        calendar_notes: List[str] = []
                        saved_task = None
                        if calendar_task_service:
                            try:
                                # „Åæ„ÅöTaskRequest„ÇíÂèñÂæó„Åó„Å¶notion_page_id„ÇíÁ¢∫Ë™ç
                                saved_task = await task_service.task_repository.find_by_id(task_id)
                                if saved_task and saved_task.notion_page_id:
                                    print(f"üîç TaskRequest found: {task_id}, notion_page_id: {saved_task.notion_page_id}")
                                    # Notion„Åã„Çâ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó
                                    task_data = await notion_service.get_task_by_id(saved_task.notion_page_id)
                                    if task_data:
                                        # ÊâøË™çËÄÖ„ÅÆSlack ID„ÇíÂèñÂæó
                                        approver_slack_id = payload.get("user", {}).get("id")

                                        # „Ç´„É¨„É≥„ÉÄ„Éº„Çø„Çπ„ÇØ„Çí‰ΩúÊàê
                                        calendar_task = await calendar_task_service.create_task_on_approval(
                                            task_data=task_data,
                                            approver_slack_user_id=approver_slack_id
                                        )

                                        if calendar_task:
                                            calendar_notes.append("üìÖ Google„Ç´„É¨„É≥„ÉÄ„Éº„ÅÆ„Çø„Çπ„ÇØ„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü")
                                            print("‚úÖ Google Calendar task created")
                                        else:
                                            calendar_notes.append("‚ö†Ô∏è Google„Ç´„É¨„É≥„ÉÄ„Éº„Å∏„ÅÆËøΩÂä†„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„Åæ„Åó„ÅüÔºà„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºâ")
                                    else:
                                        calendar_notes.append("‚ö†Ô∏è Notion„Åã„Çâ„Çø„Çπ„ÇØ„Éá„Éº„Çø„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü")
                                        print(f"‚ö†Ô∏è Could not get task data from Notion for page_id: {saved_task.notion_page_id}")
                                else:
                                    calendar_notes.append("‚ö†Ô∏è „Çø„Çπ„ÇØ„Åæ„Åü„ÅØNotion„Éö„Éº„Ç∏ID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                                    print(f"‚ö†Ô∏è TaskRequest not found or missing notion_page_id: task_id={task_id}")
                            except Exception as cal_error:
                                print(f"‚ö†Ô∏è Calendar task creation error: {cal_error}")
                                calendar_notes.append("‚ö†Ô∏è Google„Ç´„É¨„É≥„ÉÄ„Éº„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")

                        # ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫Ôºà„ÉÅ„É£„É≥„Éç„É´„ÄÅTS„ÄÅ„É°„ÉÉ„Çª„Éº„Ç∏ID„ÅåÂøÖË¶ÅÔºâ
                        # Slack „É°„ÉÉ„Çª„Éº„Ç∏Êõ¥Êñ∞„ÅÆ„Åü„ÇÅ„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å®TS„ÇíÂèñÂæó
                        message = payload.get("message", {})
                        channel = payload.get("channel", {}).get("id")
                        message_ts = message.get("ts")
                        
                        if channel and message_ts:
                            try:
                                if not saved_task:
                                    saved_task = await task_service.task_repository.find_by_id(task_id)

                                notion_page_id = approval_result.notion_page_id or (
                                    saved_task.notion_page_id if saved_task else None
                                )
                                requester_slack_id = approval_result.requester_slack_id or (
                                    saved_task.requester_slack_id if saved_task else None
                                )
                                title_text = (approval_result.title or (saved_task.title if saved_task else "„Çø„Çπ„ÇØ")).strip()
                                title_text = title_text.replace("\n", " ")
                                stage_label = REMINDER_STAGE_LABELS.get("ÊâøË™çÊ∏à", "ÊâøË™çÊ∏à„Åø")
                                header_text = f"{stage_label} - {title_text}"[:150]

                                status_lines = ["‚úÖ „Åì„ÅÆ„Çø„Çπ„ÇØ„ÅØÊâøË™ç„Åï„Çå„ÄÅNotion„Å´ÁôªÈå≤„Åï„Çå„Åæ„Åó„Åü"]
                                status_lines.extend(calendar_notes)
                                status_text = "\n".join(status_lines)

                                blocks: List[Dict[str, Any]] = [
                                    {
                                        "type": "header",
                                        "text": {"type": "plain_text", "text": header_text, "emoji": True},
                                    },
                                    {
                                        "type": "section",
                                        "text": {"type": "mrkdwn", "text": status_text},
                                    },
                                ]

                                action_payload = None
                                notion_url = None
                                if notion_page_id:
                                    notion_url = f"https://www.notion.so/{notion_page_id.replace('-', '')}"
                                    title_display = title_text or "(‰ª∂ÂêçÊú™Ë®≠ÂÆö)"
                                    due_source = approval_result.due_date or (saved_task.due_date if saved_task else None)
                                    due_text = _format_datetime_text(due_source)

                                    blocks.append(
                                        {
                                            "type": "section",
                                            "fields": [
                                                {
                                                    "type": "mrkdwn",
                                                    "text": f"‰ª∂Âêç: <{notion_url}|{title_display}>",
                                                },
                                                {
                                                    "type": "mrkdwn",
                                                    "text": f"Á¥çÊúü: {due_text if due_text else '-'}",
                                                },
                                            ],
                                        }
                                    )

                                    if requester_slack_id:
                                        action_payload = json.dumps(
                                            {
                                                "page_id": notion_page_id,
                                                "stage": "ÊâøË™çÊ∏à",
                                                "requester_slack_id": requester_slack_id,
                                            }
                                        )

                                action_elements: List[Dict[str, Any]] = []
                                if notion_url:
                                    action_elements.append(
                                        {
                                            "type": "button",
                                            "action_id": "open_notion_page",
                                            "text": {"type": "plain_text", "text": "üìù Notion„ÇíÈñã„Åè", "emoji": True},
                                            "url": notion_url,
                                        }
                                    )

                                if action_payload:
                                    action_elements.append(
                                        {
                                            "type": "button",
                                            "text": {"type": "plain_text", "text": "‚úÖ ÂÆå‰∫ÜÂ†±Âëä", "emoji": True},
                                            "style": "primary",
                                            "action_id": "open_completion_modal",
                                            "value": action_payload,
                                        }
                                    )
                                    action_elements.append(
                                        {
                                            "type": "button",
                                            "text": {"type": "plain_text", "text": "‚è≥ Âª∂ÊúüÁî≥Ë´ã", "emoji": True},
                                            "action_id": "open_extension_modal",
                                            "value": action_payload,
                                        }
                                    )

                                if action_elements:
                                    blocks.append(
                                        {
                                            "type": "actions",
                                            "elements": action_elements,
                                        }
                                    )

                                if action_payload:
                                    blocks.append(
                                        {
                                            "type": "context",
                                            "elements": [
                                                {
                                                    "type": "mrkdwn",
                                                    "text": "ÂÆå‰∫ÜÂ†±Âëä„ÅØ‰æùÈ†ºËÄÖ„Å´ÈÄÅ‰ø°„Åï„Çå„Åæ„Åô„ÄÇÂª∂ÊúüÁî≥Ë´ã„ÅØ‰æùÈ†ºËÄÖ„Å´„Çà„ÇãÊâøË™çÂæå„Å´ÂèçÊò†„Åï„Çå„Åæ„Åô„ÄÇ",
                                                }
                                            ],
                                        }
                                    )

                                slack_service.client.chat_update(
                                    channel=channel,
                                    ts=message_ts,
                                    text="‚úÖ „Çø„Çπ„ÇØ„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü",
                                    blocks=blocks,
                                )
                            except Exception as update_error:
                                print(f"‚ö†Ô∏è „É°„ÉÉ„Çª„Éº„Ç∏Êõ¥Êñ∞„Ç®„É©„Éº: {update_error}")
                                
                    except Exception as e:
                        print(f"‚ùå ÊâøË™çÂá¶ÁêÜ„Ç®„É©„Éº: {e}")
                        
                        # „Ç®„É©„ÉºÊôÇ„ÅÆË°®Á§∫ÔºàÂÜçË©¶Ë°å„Éú„Çø„É≥‰ªò„ÅçÔºâ
                        message = payload.get("message", {})
                        channel = payload.get("channel", {}).get("id")
                        message_ts = message.get("ts")
                        
                        if channel and message_ts:
                            try:
                                slack_service.client.chat_update(
                                    channel=channel,
                                    ts=message_ts,
                                    text="‚ùå ÊâøË™çÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
                                    blocks=[
                                        {
                                            "type": "section",
                                            "text": {
                                                "type": "mrkdwn",
                                                "text": f"‚ùå *ÊâøË™çÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü*\n\n{str(e)}"
                                            }
                                        },
                                        {
                                            "type": "actions",
                                            "elements": [
                                                {
                                                    "type": "button",
                                                    "text": {"type": "plain_text", "text": "üîÑ ÂÜçË©¶Ë°å"},
                                                    "style": "primary",
                                                    "value": task_id,
                                                    "action_id": "approve_task",
                                                },
                                            ]
                                        }
                                    ]
                                )
                            except Exception as update_error:
                                print(f"‚ö†Ô∏è „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Êõ¥Êñ∞Â§±Êïó: {update_error}")
                
                # ÈùûÂêåÊúü„Çø„Çπ„ÇØ„ÇíÈñãÂßã
                asyncio.create_task(run_approval())
                
                # Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫„ÇíËøî„Åô
                return JSONResponse(content=loading_response)
            except ValueError as e:
                # „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
                return JSONResponse(
                    content={
                        "response_action": "update",
                        "text": "‚ùå ÊâøË™çÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
                        "blocks": [
                            {
                                "type": "section",
                                "text": {
                                    "type": "mrkdwn",
                                    "text": f"‚ùå „Ç®„É©„Éº: {str(e)}",
                                },
                            }
                        ],
                    }
                )

        elif action_id == "reject_task":
            # Â∑Æ„ÅóÊàª„Åó„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åè
            await slack_service.open_rejection_modal(trigger_id, task_id)
            return JSONResponse(content={})

        elif action_id == "open_revision_modal":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for open_revision_modal")
                return JSONResponse(content={})

            task_id = value_data.get("task_id")
            if not task_id:
                return JSONResponse(content={})

            task = await task_service.task_repository.find_by_id(task_id)
            if not task:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="„Çø„Çπ„ÇØÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊñ∞„Åó„Åè‰æùÈ†º„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify requester about missing task: {dm_error}")
                return JSONResponse(content={})

            if task.requester_slack_id != user_id:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="„Åì„ÅÆÂ∑Æ„ÅóÊàª„Åó„Çø„Çπ„ÇØ„Çí‰øÆÊ≠£„Åß„Åç„Çã„ÅÆ„ÅØ‰æùÈ†ºËÄÖ„ÅÆ„Åø„Åß„Åô„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify non-requester user: {dm_error}")
                return JSONResponse(content={})

            source_channel = payload.get("channel", {}).get("id")
            message = payload.get("message", {})
            source_ts = message.get("ts")

            metadata: Dict[str, Any] = {}
            if source_channel:
                metadata["source_channel"] = source_channel
            if source_ts:
                metadata["source_ts"] = source_ts
            if task.rejection_reason:
                metadata["rejection_reason"] = task.rejection_reason

            await slack_service.open_task_revision_modal(
                trigger_id=trigger_id,
                task=task,
                requester_slack_id=user_id,
                private_metadata=metadata,
                rejection_reason=task.rejection_reason,
            )

            return JSONResponse(content={})

        elif action_id == "mark_reminder_read":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for mark_reminder_read")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            stage = value_data.get("stage")
            channel_id = payload.get("channel", {}).get("id")
            message = payload.get("message", {})
            message_ts = message.get("ts")
            message_blocks = message.get("blocks", [])

            import asyncio

            async def run_mark_read():
                if not page_id:
                    try:
                        dm = slack_service.client.conversations_open(users=user_id)
                        slack_service.client.chat_postMessage(
                            channel=dm["channel"]["id"],
                            text="„Çø„Çπ„ÇØÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÁÆ°ÁêÜËÄÖ„Å´ÈÄ£Áµ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        )
                    except Exception as dm_error:
                        print(f"‚ö†Ô∏è Failed to notify user about missing page_id: {dm_error}")
                    return

                read_time = datetime.now(JST)
                try:
                    await notion_service.mark_reminder_read(page_id, read_time, stage)
                    snapshot = await notion_service.get_task_snapshot(page_id)
                    user_info = await slack_service.get_user_info(user_id)
                    actor_email = user_info.get("profile", {}).get("email") if user_info else None
                    stage_label = REMINDER_STAGE_LABELS.get(stage, stage or "„É™„Éû„Ç§„É≥„Éâ")
                    detail = f"{stage_label} „ÇíÊó¢Ë™≠ ({read_time.astimezone().strftime('%Y-%m-%d %H:%M')})"
                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="„É™„Éû„Ç§„É≥„ÉâÊó¢Ë™≠",
                        detail=detail,
                        actor_email=actor_email,
                    )

                    if channel_id and message_ts and message_blocks:
                        try:
                            updated_text = f"‚úÖ <@{user_id}> „Åå{stage_label}„ÇíÊó¢Ë™≠ ({_format_datetime_text(datetime.now(JST))})"
                            updated_blocks = _mark_read_update_blocks(message_blocks, updated_text)
                            slack_service.client.chat_update(
                                channel=channel_id,
                                ts=message_ts,
                                blocks=updated_blocks,
                                text=updated_text,
                            )
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è Failed to update reminder message: {update_error}")

                except Exception as ack_error:
                    print(f"‚ö†Ô∏è Failed to mark reminder as read: {ack_error}")

            asyncio.create_task(run_mark_read())
            return JSONResponse(content={})

        elif action_id == "open_extension_modal":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for open_extension_modal")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            stage = value_data.get("stage")
            requester_slack_id = value_data.get("requester_slack_id")

            snapshot = await notion_service.get_task_snapshot(page_id)
            if not snapshot:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="Notion„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÂ∞ë„ÅóÂæÖ„Å£„Å¶ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify user about missing snapshot: {dm_error}")
                return JSONResponse(content={})

            if not requester_slack_id and snapshot.requester_email:
                try:
                    requester_user = await slack_user_repository.find_by_email(Email(snapshot.requester_email))
                    if requester_user:
                        requester_slack_id = str(requester_user.user_id)
                except Exception as lookup_error:
                    print(f"‚ö†Ô∏è Failed to lookup requester Slack ID: {lookup_error}")

            if not requester_slack_id:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="‰æùÈ†ºËÄÖ„ÅÆSlack„Ç¢„Ç´„Ç¶„É≥„Éà„ÅåË¶ã„Å§„Åã„Çâ„Åö„ÄÅÂª∂ÊúüÁî≥Ë´ã„ÇíÈñãÂßã„Åß„Åç„Åæ„Åõ„Çì„ÄÇÁÆ°ÁêÜËÄÖ„Å´„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify user about missing requester Slack ID: {dm_error}")
                return JSONResponse(content={})

            await slack_service.open_extension_modal(
                trigger_id=trigger_id,
                snapshot=snapshot,
                stage=stage,
                requester_slack_id=requester_slack_id,
                assignee_slack_id=user_id,
            )
            return JSONResponse(content={})

        elif action_id == "open_completion_modal":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for open_completion_modal")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            stage = value_data.get("stage")
            requester_slack_id = value_data.get("requester_slack_id")

            snapshot = await notion_service.get_task_snapshot(page_id)
            if not snapshot:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="Notion„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify user about missing snapshot: {dm_error}")
                return JSONResponse(content={})

            if not requester_slack_id and snapshot.requester_email:
                try:
                    requester_user = await slack_user_repository.find_by_email(Email(snapshot.requester_email))
                    if requester_user:
                        requester_slack_id = str(requester_user.user_id)
                except Exception as lookup_error:
                    print(f"‚ö†Ô∏è Failed to lookup requester Slack ID for completion modal: {lookup_error}")

            if not requester_slack_id:
                try:
                    dm = slack_service.client.conversations_open(users=user_id)
                    slack_service.client.chat_postMessage(
                        channel=dm["channel"]["id"],
                        text="‰æùÈ†ºËÄÖ„ÅÆSlack„Ç¢„Ç´„Ç¶„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇÁÆ°ÁêÜËÄÖ„Å´„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    )
                except Exception as dm_error:
                    print(f"‚ö†Ô∏è Failed to notify user about missing requester Slack ID: {dm_error}")
                return JSONResponse(content={})

            await slack_service.open_completion_modal(
                trigger_id=trigger_id,
                snapshot=snapshot,
                stage=stage,
                requester_slack_id=requester_slack_id,
                assignee_slack_id=user_id,
            )
            return JSONResponse(content={})

        elif action_id == "approve_completion_request":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for approve_completion_request")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            assignee_slack_id = value_data.get("assignee_slack_id")
            requester_slack_id = value_data.get("requester_slack_id", user_id)
            channel_id = payload.get("channel", {}).get("id")
            message = payload.get("message", {})
            message_ts = message.get("ts")
            message_blocks = message.get("blocks", [])

            import asyncio

            async def run_completion_approval():
                if not page_id:
                    return
                try:
                    snapshot = await notion_service.get_task_snapshot(page_id)
                    if not snapshot:
                        slack_service.client.chat_postMessage(
                            channel=slack_service.client.conversations_open(users=user_id)["channel"]["id"],
                            text="Notion„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó„Åß„Åç„ÅöÊâøË™ç„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ",
                        )
                        return

                    approval_time = datetime.now(JST)
                    requested_before_due = _requested_on_time(
                        snapshot.completion_requested_at if snapshot else None,
                        snapshot.due_date if snapshot else None,
                    )
                    eligible_for_overdue_points = getattr(snapshot, "status", None) == TASK_STATUS_APPROVED

                    await notion_service.approve_completion(
                        page_id,
                        approval_time,
                        requested_before_due,
                    )
                    await notion_service.update_task_status(page_id, "completed")

                    user_info = await slack_service.get_user_info(user_id)
                    actor_email = user_info.get("profile", {}).get("email") if user_info else None
                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="ÂÆå‰∫ÜÊâøË™ç",
                        detail=f"ÂÆå‰∫ÜÊâøË™ç {approval_time.astimezone().strftime('%Y-%m-%d %H:%M')}",
                        actor_email=actor_email,
                    )

                    if channel_id and message_ts and message_blocks:
                        try:
                            updated_blocks = _replace_actions_with_context(
                                message_blocks,
                                f"‚úÖ ÂÆå‰∫Ü„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü ({_format_datetime_text(datetime.now(JST))})",
                            )
                            slack_service.client.chat_update(
                                channel=channel_id,
                                ts=message_ts,
                                blocks=updated_blocks,
                                text="ÂÆå‰∫Ü„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü",
                            )
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è Failed to update completion approval message: {update_error}")

                    await slack_service.notify_completion_approved(
                        assignee_slack_id=assignee_slack_id,
                        requester_slack_id=requester_slack_id,
                        snapshot=snapshot,
                        approval_time=approval_time,
                    )

                    target_points = 1 if (eligible_for_overdue_points and not requested_before_due) else 0
                    refreshed_snapshot = await notion_service.get_task_snapshot(page_id)
                    snapshot_for_metrics = refreshed_snapshot or snapshot
                    await task_metrics_service.sync_snapshot(
                        snapshot_for_metrics,
                        overdue_points=target_points,
                    )
                    await task_metrics_service.refresh_assignee_summaries()

                except Exception as approval_error:
                    print(f"‚ö†Ô∏è Completion approval failed: {approval_error}")

            asyncio.create_task(run_completion_approval())
            return JSONResponse(content={})

        elif action_id == "reject_completion_request":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for reject_completion_request")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            assignee_slack_id = value_data.get("assignee_slack_id")
            requester_slack_id = value_data.get("requester_slack_id", user_id)

            snapshot = await notion_service.get_task_snapshot(page_id)
            if not snapshot:
                slack_service.client.chat_postMessage(
                    channel=slack_service.client.conversations_open(users=user_id)["channel"]["id"],
                    text="Notion„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ",
                )
                return JSONResponse(content={})

            await slack_service.open_completion_reject_modal(
                trigger_id=trigger_id,
                snapshot=snapshot,
                assignee_slack_id=assignee_slack_id,
                requester_slack_id=requester_slack_id,
            )
            return JSONResponse(content={})

        elif action_id == "approve_extension_request":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for approve_extension_request")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            assignee_slack_id = value_data.get("assignee_slack_id")
            requester_slack_id = value_data.get("requester_slack_id", user_id)
            channel_id = payload.get("channel", {}).get("id")
            message = payload.get("message", {})
            message_ts = message.get("ts")
            message_blocks = message.get("blocks", [])

            import asyncio

            async def run_extension_approval():
                if not page_id:
                    return
                try:
                    snapshot = await notion_service.get_task_snapshot(page_id)
                    if not snapshot or not snapshot.extension_requested_due:
                        info = "Âª∂ÊúüÁî≥Ë´ã„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åü„ÇÅÊâøË™ç„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
                        slack_service.client.chat_postMessage(
                            channel=slack_service.client.conversations_open(users=user_id)["channel"]["id"],
                            text=info,
                        )
                        return

                    approved_due = snapshot.extension_requested_due
                    previous_due = snapshot.due_date

                    await notion_service.approve_extension(page_id, approved_due)
                    user_info = await slack_service.get_user_info(user_id)
                    actor_email = user_info.get("profile", {}).get("email") if user_info else None
                    detail = (
                        f"Âª∂ÊúüÊâøË™ç: {_format_datetime_text(previous_due)} ‚Üí {_format_datetime_text(approved_due)}"
                        if previous_due
                        else f"Âª∂ÊúüÊâøË™ç: Êñ∞ÊúüÊó• {_format_datetime_text(approved_due)}"
                    )
                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="Âª∂ÊúüÊâøË™ç",
                        detail=detail,
                        actor_email=actor_email,
                    )

                    updated_blocks = _replace_actions_with_context(
                        message_blocks,
                        f"‚úÖ Âª∂Êúü„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü ({_format_datetime_text(datetime.now(JST))})",
                    ) if message_blocks else None

                    if channel_id and message_ts and updated_blocks:
                        try:
                            slack_service.client.chat_update(
                                channel=channel_id,
                                ts=message_ts,
                                blocks=updated_blocks,
                                text="Âª∂Êúü„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü",
                            )
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è Failed to update approval message: {update_error}")

                    await slack_service.notify_extension_approved(
                        assignee_slack_id=assignee_slack_id,
                        requester_slack_id=requester_slack_id,
                        snapshot=snapshot,
                        new_due=approved_due,
                    )

                    refreshed_snapshot = await notion_service.get_task_snapshot(page_id)
                    snapshot_for_metrics = refreshed_snapshot or snapshot
                    await task_metrics_service.sync_snapshot(
                        snapshot_for_metrics,
                        reminder_stage=snapshot_for_metrics.reminder_stage,
                    )
                    await task_metrics_service.refresh_assignee_summaries()

                except Exception as approval_error:
                    print(f"‚ö†Ô∏è Extension approval failed: {approval_error}")

            asyncio.create_task(run_extension_approval())
            return JSONResponse(content={})

        elif action_id == "reject_extension_request":
            try:
                value_data = json.loads(action.get("value", "{}"))
            except json.JSONDecodeError:
                print("‚ö†Ô∏è Invalid payload for reject_extension_request")
                return JSONResponse(content={})

            page_id = value_data.get("page_id")
            assignee_slack_id = value_data.get("assignee_slack_id")
            requester_slack_id = value_data.get("requester_slack_id", user_id)
            channel_id = payload.get("channel", {}).get("id")
            message = payload.get("message", {})
            message_ts = message.get("ts")
            message_blocks = message.get("blocks", [])

            import asyncio

            async def run_extension_rejection():
                if not page_id:
                    return
                try:
                    snapshot = await notion_service.get_task_snapshot(page_id)
                    await notion_service.reject_extension(page_id)
                    user_info = await slack_service.get_user_info(user_id)
                    actor_email = user_info.get("profile", {}).get("email") if user_info else None
                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="Âª∂ÊúüÂç¥‰∏ã",
                        detail="‰æùÈ†ºËÄÖ„ÅåÂª∂ÊúüÁî≥Ë´ã„ÇíÂç¥‰∏ã„Åó„Åæ„Åó„Åü",
                        actor_email=actor_email,
                    )

                    if channel_id and message_ts and message_blocks:
                        try:
                            updated_blocks = _replace_actions_with_context(
                                message_blocks,
                                f"‚ö†Ô∏è Âª∂ÊúüÁî≥Ë´ã„ÇíÂç¥‰∏ã„Åó„Åæ„Åó„Åü ({_format_datetime_text(datetime.now(JST))})",
                            )
                            slack_service.client.chat_update(
                                channel=channel_id,
                                ts=message_ts,
                                blocks=updated_blocks,
                                text="Âª∂ÊúüÁî≥Ë´ã„ÇíÂç¥‰∏ã„Åó„Åæ„Åó„Åü",
                            )
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è Failed to update rejection message: {update_error}")

                    await slack_service.notify_extension_rejected(
                        assignee_slack_id=assignee_slack_id,
                        requester_slack_id=requester_slack_id,
                        snapshot=snapshot,
                    )

                    refreshed_snapshot = await notion_service.get_task_snapshot(page_id)
                    snapshot_for_metrics = refreshed_snapshot or snapshot
                    await task_metrics_service.sync_snapshot(
                        snapshot_for_metrics,
                        reminder_stage=snapshot_for_metrics.reminder_stage,
                    )
                    await task_metrics_service.refresh_assignee_summaries()

                except Exception as rejection_error:
                    print(f"‚ö†Ô∏è Extension rejection failed: {rejection_error}")

            asyncio.create_task(run_extension_rejection())
            return JSONResponse(content={})

        elif action_id == "open_notion_page":
            # URL„Éú„Çø„É≥„ÅØ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÅ¥„ÅßÈñã„Åã„Çå„Çã„Åü„ÇÅACK„ÅÆ„ÅøËøî„Åô
            return JSONResponse(content={})

        elif action_id == "ai_enhance_button":
            # AIË£úÂÆå„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ: „Åæ„ÅöÂç≥ÊôÇACK„Åó„ÄÅ„Åù„ÅÆÂæåÈùûÂêåÊúü„ÅßÊõ¥Êñ∞
            print(f"ü§ñ AIË£úÂÆå„Éú„Çø„É≥Êäº‰∏ã: user_id={user_id}, action_id={action_id}")
            return await handle_ai_enhancement_async(payload, trigger_id, view_id, user_id)
        
        else:
            print(f"‚ö†Ô∏è Unknown action_id: {action_id}")
            return JSONResponse(content={"response_action": "errors", "errors": {"general": f"‰∏çÊòé„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥: {action_id}"}})

    elif interaction_type == "view_submission":
        # „É¢„Éº„ÉÄ„É´ÈÄÅ‰ø°„ÅÆÂá¶ÁêÜ
        view = payload["view"]
        callback_id = view["callback_id"]

        if callback_id == "create_task_modal":
            try:
                # „Çø„Çπ„ÇØ‰ΩúÊàê„É¢„Éº„ÉÄ„É´„ÅÆÂá¶ÁêÜÔºàÈùûÂêåÊúüÂåñÔºâ
                values = view["state"]["values"]
                private_metadata = json.loads(view.get("private_metadata", "{}"))
                view_id = view.get("id")
                
                # „Éá„Éê„ÉÉ„Ç∞: Âèó‰ø°„Åó„Åü„Éá„Éº„ÇøÊßãÈÄ†„ÇíÁ¢∫Ë™ç
                print(f"üîç Modal values keys: {list(values.keys())}")
                for key, value in values.items():
                    print(f"  {key}: {list(value.keys())}")

                # Êñ∞„Åó„ÅÑ„Éï„Ç£„Éº„É´„Éâ„ÇíÂèñÂæóÔºàÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§Ôºâ
                task_type = "Á§æÂÜÖ„Çø„Çπ„ÇØ"  # „Éá„Éï„Ç©„É´„ÉàÂÄ§
                if "task_type_block" in values and "task_type_select" in values["task_type_block"]:
                    task_type_data = values["task_type_block"]["task_type_select"].get("selected_option")
                    if task_type_data:
                        task_type = task_type_data["value"]
                
                urgency = "1ÈÄ±Èñì‰ª•ÂÜÖ"  # „Éá„Éï„Ç©„É´„ÉàÂÄ§
                if "urgency_block" in values and "urgency_select" in values["urgency_block"]:
                    urgency_data = values["urgency_block"]["urgency_select"].get("selected_option")
                    if urgency_data:
                        urgency = urgency_data["value"]
                
                print(f"üéØ ÂèñÂæó„Åó„Åü„Éï„Ç£„Éº„É´„Éâ: task_type={task_type}, urgency={urgency}")
                
                # „É™„ÉÉ„ÉÅ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæóÔºà„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºâ
                description_data = None
                if "description_block" in values and values["description_block"]["description_input"].get("rich_text_value"):
                    description_rich = values["description_block"]["description_input"]["rich_text_value"]
                    description_data = description_rich

                # Á¥çÊúü„Çídatetime„Å´Â§âÊèõ
                due_date_unix = values["due_date_block"]["due_date_picker"]["selected_date_time"]
                due_date = datetime.fromtimestamp(due_date_unix, tz=timezone.utc).astimezone(JST)

                dto = CreateTaskRequestDto(
                    requester_slack_id=private_metadata["requester_id"],
                    assignee_slack_id=values["assignee_block"]["assignee_select"]["selected_option"]["value"],
                    title=values["title_block"]["title_input"]["value"],
                    description=description_data,  # „É™„ÉÉ„ÉÅ„ÉÜ„Ç≠„Çπ„Éà„Éá„Éº„Çø„ÇíÊ∏°„ÅôÔºà„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºâ
                    due_date=due_date,
                    task_type=task_type,
                    urgency=urgency,
                )

                # 1) Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞ÁîªÈù¢„ÇíËøî„ÅôÔºà3ÁßíÂà∂ÈôêÂõûÈÅøÔºâ
                loading_view = {
                    "type": "modal",
                    "callback_id": "task_creating_loading",
                    "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†º‰ΩúÊàê‰∏≠"},
                    "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": "‚è≥ *„Çø„Çπ„ÇØ‰æùÈ†º„Çí‰ΩúÊàê„Åó„Å¶„ÅÑ„Åæ„Åô...*\n\n„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                            }
                        }
                    ]
                }

                # 2) „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„Çø„Çπ„ÇØ‰ΩúÊàêÂá¶ÁêÜ„ÇíÂÆüË°å
                import asyncio
                
                async def run_task_creation():
                    try:
                        print("üîÑ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Çø„Çπ„ÇØ‰ΩúÊàêÈñãÂßã...")
                        await task_service.create_task_request(dto)
                        print("‚úÖ „Çø„Çπ„ÇØ‰ΩúÊàêÊàêÂäü")
                        
                        # ÊàêÂäüÊôÇ: ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
                        if view_id:
                            try:
                                success_view = {
                                    "type": "modal",
                                    "callback_id": "task_created_success",
                                    "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†ºÂÆå‰∫Ü"},
                                    "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                    "blocks": [
                                        {
                                            "type": "section",
                                            "text": {
                                                "type": "mrkdwn",
                                                "text": f"‚úÖ *„Çø„Çπ„ÇØ‰æùÈ†º„ÅåÊ≠£Â∏∏„Å´ÈÄÅ‰ø°„Åï„Çå„Åæ„Åó„Åü*\n\n*‰ª∂Âêç:* {dto.title}\n*‰æùÈ†ºÂÖà:* <@{dto.assignee_slack_id}>\n\nÊâøË™çÂæÖ„Å°„Åß„Åô„ÄÇÁµêÊûú„ÅØDM„Åß„ÅäÁü•„Çâ„Åõ„Åó„Åæ„Åô„ÄÇ"
                                            }
                                        }
                                    ]
                                }
                                slack_service.client.views_update(view_id=view_id, view=success_view)
                            except Exception as e:
                                print(f"‚ö†Ô∏è ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫„Ç®„É©„Éº: {e}")
                                
                    except Exception as e:
                        print(f"‚ùå „Çø„Çπ„ÇØ‰ΩúÊàê„Ç®„É©„Éº: {e}")
                        
                        # Â§±ÊïóÊôÇ: ÂÖÉ„ÅÆ„Éï„Ç©„Éº„É†„Å´Êàª„ÇãÔºàÂÄ§„Çí‰øùÊåÅÔºâ
                        if view_id:
                            try:
                                # ÂÖÉ„ÅÆ„Éï„Ç©„Éº„É†ÊßãÈÄ†„ÇíÂÜçÊßãÁØâ
                                error_view = {
                                    "type": "modal",
                                    "callback_id": "create_task_modal",
                                    "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†º‰ΩúÊàê"},
                                    "submit": {"type": "plain_text", "text": "‰ΩúÊàê"},
                                    "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
                                    "blocks": [
                                        {
                                            "type": "section",
                                            "text": {
                                                "type": "mrkdwn",
                                                "text": f"‚ùå *„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü*\n{str(e)}\n\n‰∏ãË®ò„ÅÆ„Éï„Ç©„Éº„É†„ÅßÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑÔºö"
                                            }
                                        },
                                        # ÂÖÉ„ÅÆ„Éï„Ç©„Éº„É†„Éñ„É≠„ÉÉ„ÇØ„ÇíÂÜçÊßãÁØâÔºàÂÄ§„Çí‰øùÊåÅÔºâ
                                        *_rebuild_task_form_blocks_with_values(values, task_type, urgency)
                                    ],
                                    "private_metadata": json.dumps(private_metadata)
                                }
                                slack_service.client.views_update(view_id=view_id, view=error_view)
                            except Exception as update_error:
                                print(f"‚ö†Ô∏è „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫Â§±Êïó: {update_error}")

                # ÈùûÂêåÊúü„Çø„Çπ„ÇØ„ÇíÈñãÂßã
                asyncio.create_task(run_task_creation())

                # Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞ÁîªÈù¢„ÇíËøî„Åô
                return JSONResponse(
                    content={
                        "response_action": "update",
                        "view": loading_view
                    }
                )
            except ValueError as e:
                # „Çø„Çπ„ÇØ‰ΩúÊàê„Ç®„É©„Éº„ÅÆÂ†¥Âêà
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {
                            "title_block": f"„Ç®„É©„Éº: {str(e)}"
                        }
                    }
                )

        elif callback_id == "revise_task_modal":
            values = view["state"]["values"]
            private_metadata = json.loads(view.get("private_metadata", "{}"))
            view_id = view.get("id")

            task_id = private_metadata.get("task_id")
            requester_slack_id = private_metadata.get("requester_slack_id") or payload.get("user", {}).get("id")
            if not task_id or not requester_slack_id:
                return JSONResponse(content={"response_action": "clear"})

            assignee_option = values.get("assignee_block", {}).get("assignee_select", {}).get("selected_option")
            title_value = values.get("title_block", {}).get("title_input", {}).get("value")
            due_picker = values.get("due_date_block", {}).get("due_date_picker", {})

            if not assignee_option or not title_value or not due_picker.get("selected_date_time"):
                errors: Dict[str, Optional[str]] = {}
                if not assignee_option:
                    errors["assignee_block"] = "‰æùÈ†ºÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
                if not title_value:
                    errors["title_block"] = "‰ª∂Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
                if not due_picker.get("selected_date_time"):
                    errors["due_date_block"] = "Á¥çÊúü„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": errors,
                    }
                )

            task_type_option = values.get("task_type_block", {}).get("task_type_select", {}).get("selected_option")
            urgency_option = values.get("urgency_block", {}).get("urgency_select", {}).get("selected_option")

            task_type = task_type_option["value"] if task_type_option else "Á§æÂÜÖ„Çø„Çπ„ÇØ"
            urgency = urgency_option["value"] if urgency_option else "1ÈÄ±Èñì‰ª•ÂÜÖ"

            description_data = None
            description_payload = values.get("description_block", {}).get("description_input", {})
            if description_payload.get("rich_text_value"):
                description_data = description_payload.get("rich_text_value")

            due_date = datetime.fromtimestamp(due_picker["selected_date_time"], tz=timezone.utc).astimezone(JST)

            dto = ReviseTaskRequestDto(
                task_id=task_id,
                requester_slack_id=requester_slack_id,
                assignee_slack_id=assignee_option["value"],
                title=title_value,
                description=description_data,
                due_date=due_date,
                task_type=task_type,
                urgency=urgency,
            )

            loading_view = {
                "type": "modal",
                "callback_id": "revise_task_modal_loading",
                "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†º„Çí‰øÆÊ≠£"},
                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "‚è≥ *‰øÆÊ≠£„Åó„Åü„Çø„Çπ„ÇØ„ÇíÈÄÅ‰ø°„Åó„Å¶„ÅÑ„Åæ„Åô...*\nÊï∞Áßí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        },
                    }
                ],
            }

            source_channel = private_metadata.get("source_channel")
            source_ts = private_metadata.get("source_ts")

            import asyncio

            async def run_task_revision():
                try:
                    response = await task_service.revise_task_request(dto)

                    if source_channel and source_ts:
                        try:
                            formatted_due = _format_datetime_text(due_date)
                            updated_blocks = [
                                {
                                    "type": "header",
                                    "text": {"type": "plain_text", "text": "‚úèÔ∏è „Çø„Çπ„ÇØ„Çí‰øÆÊ≠£„Åó„Å¶ÂÜçÈÄÅ‰ø°„Åó„Åæ„Åó„Åü"},
                                },
                                {
                                    "type": "section",
                                    "text": {
                                        "type": "mrkdwn",
                                        "text": f"*‰ª∂Âêç:* {response.title}\n*‰æùÈ†ºÂÖà:* <@{dto.assignee_slack_id}>\n*Á¥çÊúü:* {formatted_due}",
                                    },
                                },
                                {
                                    "type": "context",
                                    "elements": [
                                        {"type": "mrkdwn", "text": "‰øÆÊ≠£ÂÜÖÂÆπ„ÇíÈÄÅ‰ø°„Åó„ÄÅÂÜç„Å≥ÊâøË™çÂæÖ„Å°„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ"},
                                    ],
                                },
                            ]

                            slack_service.client.chat_update(
                                channel=source_channel,
                                ts=source_ts,
                                text="„Çø„Çπ„ÇØ„Çí‰øÆÊ≠£„Åó„Å¶ÂÜçÈÄÅ„Åó„Åæ„Åó„Åü",
                                blocks=updated_blocks,
                            )
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è Failed to update rejection message after revision: {update_error}")

                    if view_id:
                        try:
                            success_view = {
                                "type": "modal",
                                "callback_id": "revise_task_modal_success",
                                "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†º„Çí‰øÆÊ≠£"},
                                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                "blocks": [
                                    {
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": "‚úÖ *‰øÆÊ≠£„Åó„Åü„Çø„Çπ„ÇØ„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü*\nÊâøË™çÁµêÊûú„ÅØ‰æùÈ†ºÂÖà„Åã„Çâ„ÅÆÈÄöÁü•„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ",
                                        },
                                    }
                                ],
                            }
                            slack_service.client.views_update(view_id=view_id, view=success_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ‰øÆÊ≠£ÊàêÂäü„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

                except Exception as revision_error:
                    print(f"‚ö†Ô∏è Task revision failed: {revision_error}")
                    if view_id:
                        try:
                            error_view = {
                                "type": "modal",
                                "callback_id": "revise_task_modal_error",
                                "title": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ‰æùÈ†º„Çí‰øÆÊ≠£"},
                                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                "blocks": [
                                    {
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": f"‚ö†Ô∏è *‰øÆÊ≠£„Åó„Åü„Çø„Çπ„ÇØ„ÅÆÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü*\n{revision_error}",
                                        },
                                    }
                                ],
                            }
                            slack_service.client.views_update(view_id=view_id, view=error_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ‰øÆÊ≠£„Ç®„É©„Éº„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

            asyncio.create_task(run_task_revision())

            return JSONResponse(
                content={
                    "response_action": "update",
                    "view": loading_view,
                }
            )

        elif callback_id == "reject_task_modal":
            try:
                # Â∑Æ„ÅóÊàª„Åó„É¢„Éº„ÉÄ„É´„ÅÆÂá¶ÁêÜÔºàÈùûÂêåÊúüÂåñÔºâ
                values = view["state"]["values"]
                private_metadata = json.loads(view.get("private_metadata", "{}"))
                view_id = view.get("id")
                task_id = private_metadata["task_id"]
                reason = values["reason_block"]["reason_input"]["value"]

                # Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫
                loading_view = {
                    "type": "modal",
                    "callback_id": "task_rejecting_loading",
                    "title": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„Åó‰∏≠"},
                    "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": "‚è≥ *„Çø„Çπ„ÇØ„ÇíÂ∑Æ„ÅóÊàª„Åó„Å¶„ÅÑ„Åæ„Åô...*\n\n„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                            }
                        }
                    ]
                }
                
                # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂ∑Æ„ÅóÊàª„ÅóÂá¶ÁêÜ„ÇíÂÆüË°å
                import asyncio
                
                async def run_rejection():
                    try:
                        dto = TaskApprovalDto(
                            task_id=task_id,
                            action="reject",
                            rejection_reason=reason,
                        )
                        await task_service.handle_task_approval(dto)
                        print("‚úÖ Â∑Æ„ÅóÊàª„ÅóÂá¶ÁêÜÊàêÂäü")
                        
                        # ÊàêÂäüÊôÇÔºö„É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã
                        if view_id:
                            try:
                                success_view = {
                                    "type": "modal",
                                    "callback_id": "task_rejected_success",
                                    "title": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„ÅóÂÆå‰∫Ü"},
                                    "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                    "blocks": [
                                        {
                                            "type": "section",
                                            "text": {
                                                "type": "mrkdwn",
                                                "text": f"‚úÖ *„Çø„Çπ„ÇØ„ÇíÂ∑Æ„ÅóÊàª„Åó„Åæ„Åó„Åü*\n\n*ÁêÜÁî±:* {reason}"
                                            }
                                        }
                                    ]
                                }
                                slack_service.client.views_update(view_id=view_id, view=success_view)
                            except Exception as update_error:
                                print(f"‚ö†Ô∏è ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫„Ç®„É©„Éº: {update_error}")
                                
                    except Exception as e:
                        print(f"‚ùå Â∑Æ„ÅóÊàª„ÅóÂá¶ÁêÜ„Ç®„É©„Éº: {e}")
                        
                        # „Ç®„É©„ÉºÊôÇÔºöÂÖÉ„ÅÆ„Éï„Ç©„Éº„É†„Å´Êàª„ÇãÔºàÂÄ§„Çí‰øùÊåÅÔºâ
                        if view_id:
                            try:
                                error_view = {
                                    "type": "modal",
                                    "callback_id": "reject_task_modal",
                                    "title": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„ÅóÁêÜÁî±"},
                                    "submit": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„Åô"},
                                    "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
                                    "blocks": [
                                        {
                                            "type": "section",
                                            "text": {
                                                "type": "mrkdwn",
                                                "text": f"‚ùå *„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü*\n{str(e)}\n\n‰∏ãË®ò„ÅÆ„Éï„Ç©„Éº„É†„ÅßÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑÔºö"
                                            }
                                        },
                                        {
                                            "type": "input",
                                            "block_id": "reason_block",
                                            "element": {
                                                "type": "plain_text_input",
                                                "multiline": True,
                                                "action_id": "reason_input",
                                                "placeholder": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„ÅóÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"},
                                                "initial_value": reason  # ÂÖ•Âäõ„Åó„ÅüÁêÜÁî±„Çí‰øùÊåÅ
                                            },
                                            "label": {"type": "plain_text", "text": "Â∑Æ„ÅóÊàª„ÅóÁêÜÁî±"},
                                        },
                                    ],
                                    "private_metadata": json.dumps(private_metadata)
                                }
                                slack_service.client.views_update(view_id=view_id, view=error_view)
                            except Exception as update_error:
                                print(f"‚ö†Ô∏è „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫Â§±Êïó: {update_error}")
                
                # ÈùûÂêåÊúü„Çø„Çπ„ÇØ„ÇíÈñãÂßã
                asyncio.create_task(run_rejection())
                
                # Âç≥Â∫ß„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞ÁîªÈù¢„ÇíËøî„Åô
                return JSONResponse(
                    content={
                        "response_action": "update",
                        "view": loading_view
                    }
                )
            except ValueError as e:
                # „Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åô
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {
                            "reason_block": f"„Ç®„É©„Éº: {str(e)}"
                        }
                    }
                )
        
        elif callback_id == "ai_additional_info_modal":
            # ËøΩÂä†ÊÉÖÂ†±ÂÖ•Âäõ„É¢„Éº„ÉÄ„É´„ÅÆÂá¶ÁêÜ
            return await handle_additional_info_submission(payload)
            
        elif callback_id == "ai_content_confirmation_modal":
            # ÂÜÖÂÆπÁ¢∫Ë™ç„É¢„Éº„ÉÄ„É´„ÅÆÂá¶ÁêÜ
            return await handle_content_confirmation(payload)

        elif callback_id == "extension_request_modal":
            values = view["state"]["values"]
            private_metadata = json.loads(view.get("private_metadata", "{}"))

            due_data = values.get("new_due_block", {}).get("new_due_picker", {})
            selected_ts = due_data.get("selected_date_time")
            if not selected_ts:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {
                            "new_due_block": "Êñ∞„Åó„ÅÑÁ¥çÊúü„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        },
                    }
                )

            reason = _get_text_input_value(values, "reason_block", "reason_input")
            if not reason:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {
                            "reason_block": "Âª∂ÊúüÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        },
                    }
                )

            requested_due = datetime.fromtimestamp(selected_ts, tz=timezone.utc).astimezone(JST)
            page_id = private_metadata.get("page_id")
            stage = private_metadata.get("stage")
            requester_slack_id = private_metadata.get("requester_slack_id")
            assignee_slack_id = private_metadata.get("assignee_slack_id")

            if not page_id:
                return JSONResponse(content={"response_action": "clear"})

            snapshot = await notion_service.get_task_snapshot(page_id)
            if not snapshot:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {
                            "reason_block": "Notion„Éá„Éº„Çø„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ",
                        },
                    }
                )

            await notion_service.set_extension_request(page_id, requested_due, reason)
            await notion_service.record_audit_log(
                task_page_id=page_id,
                event_type="Âª∂ÊúüÁî≥Ë´ã",
                detail=f"{_format_datetime_text(snapshot.due_date)} ‚Üí {_format_datetime_text(requested_due)}\nÁêÜÁî±: {reason}",
                actor_email=snapshot.assignee_email,
            )

            target_requester_slack_id = requester_slack_id
            if not target_requester_slack_id and snapshot.requester_email:
                try:
                    slack_user = await slack_user_repository.find_by_email(Email(snapshot.requester_email))
                    if slack_user:
                        target_requester_slack_id = str(slack_user.user_id)
                except Exception as lookup_error:
                    print(f"‚ö†Ô∏è Failed to lookup requester Slack ID during extension submission: {lookup_error}")

            if target_requester_slack_id:
                try:
                    await slack_service.send_extension_request_to_requester(
                        requester_slack_id=target_requester_slack_id,
                        assignee_slack_id=assignee_slack_id,
                        snapshot=snapshot,
                        requested_due=requested_due,
                        reason=reason,
                    )
                except Exception as send_error:
                    print(f"‚ö†Ô∏è Failed to send extension approval request: {send_error}")
            else:
                print("‚ö†Ô∏è Requester Slack ID not resolved. Extension approval request not delivered.")

            if assignee_slack_id:
                await slack_service.notify_extension_request_submitted(
                    assignee_slack_id=assignee_slack_id,
                    requested_due=requested_due,
                )

            return JSONResponse(content={})

        elif callback_id == "completion_request_modal":
            values = view["state"]["values"]
            private_metadata = json.loads(view.get("private_metadata", "{}"))
            require_reason = private_metadata.get("require_reason", False)

            note = _get_text_input_value(values, "note_block", "note_input")

            if require_reason and not note:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {"note_block": "ÈÅÖÂª∂ÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"},
                    }
                )

            page_id = private_metadata.get("page_id")
            requester_slack_id = private_metadata.get("requester_slack_id")
            assignee_slack_id = private_metadata.get("assignee_slack_id")
            view_id = view.get("id")

            loading_view = {
                "type": "modal",
                "callback_id": "completion_request_loading",
                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÁî≥Ë´ã"},
                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "‚è≥ *ÂÆå‰∫ÜÁî≥Ë´ã„ÇíÈÄÅ‰ø°„Åó„Å¶„ÅÑ„Åæ„Åô...*\nÊï∞Áßí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                        }
                    }
                ]
            }

            import asyncio

            async def run_completion_request():
                requested_at = datetime.now(JST)
                try:
                    snapshot = await notion_service.get_task_snapshot(page_id)
                    if not snapshot:
                        raise ValueError("Notion„Çø„Çπ„ÇØ„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü")

                    resolved_requester = requester_slack_id
                    if not resolved_requester and snapshot.requester_email:
                        requester_user = await slack_user_repository.find_by_email(Email(snapshot.requester_email))
                        if requester_user:
                            resolved_requester = str(requester_user.user_id)

                    if not resolved_requester:
                        raise ValueError("‰æùÈ†ºËÄÖ„ÅÆSlack„Ç¢„Ç´„Ç¶„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")

                    requested_before_due = _requested_on_time(requested_at, snapshot.due_date)
                    eligible_for_overdue_points = getattr(snapshot, "status", None) == TASK_STATUS_APPROVED

                    await notion_service.request_completion(
                        page_id=page_id,
                        request_time=requested_at,
                        note=note,
                        requested_before_due=requested_before_due,
                    )

                    target_points = 1 if (eligible_for_overdue_points and not requested_before_due) else 0
                    refreshed_snapshot = await notion_service.get_task_snapshot(page_id)
                    snapshot_for_metrics = refreshed_snapshot or snapshot
                    await task_metrics_service.sync_snapshot(
                        snapshot_for_metrics,
                        overdue_points=target_points,
                    )
                    await task_metrics_service.refresh_assignee_summaries()

                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="ÂÆå‰∫ÜÁî≥Ë´ã",
                        detail=f"ÂÆå‰∫ÜÊó•ÊôÇ: {_format_datetime_text(requested_at)}\n„É°„É¢: {note or 'Ôºà„Å™„ÅóÔºâ'}",
                        actor_email=snapshot.assignee_email,
                    )

                    await slack_service.send_completion_request_to_requester(
                        requester_slack_id=resolved_requester,
                        assignee_slack_id=assignee_slack_id,
                        snapshot=snapshot,
                        completion_note=note,
                        requested_at=requested_at,
                        overdue=not requested_before_due,
                    )

                    if assignee_slack_id:
                        await slack_service.notify_completion_request_submitted(assignee_slack_id)

                    if view_id:
                        try:
                            success_view = {
                                "type": "modal",
                                "callback_id": "completion_request_success",
                                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÁî≥Ë´ã"},
                                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                "blocks": [
                                    {
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": f"‚úÖ *ÂÆå‰∫ÜÁî≥Ë´ã„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü*\nÊâøË™çÁµêÊûú„ÅØ‰æùÈ†ºËÄÖ„Åã„Çâ„ÅÆÈÄöÁü•„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                                        }
                                    }
                                ]
                            }
                            slack_service.client.views_update(view_id=view_id, view=success_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ÂÆå‰∫ÜÁî≥Ë´ãÊàêÂäü„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

                except Exception as req_error:
                    print(f"‚ö†Ô∏è Completion request failed: {req_error}")
                    if view_id:
                        try:
                            error_view = {
                                "type": "modal",
                                "callback_id": "completion_request_error",
                                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÁî≥Ë´ã"},
                                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                "blocks": [
                                    {
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": f"‚ö†Ô∏è *ÂÆå‰∫ÜÁî≥Ë´ã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü*\n{req_error}"
                                        }
                                    }
                                ]
                            }
                            slack_service.client.views_update(view_id=view_id, view=error_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ÂÆå‰∫ÜÁî≥Ë´ã„Ç®„É©„Éº„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

            asyncio.create_task(run_completion_request())

            return JSONResponse(
                content={
                    "response_action": "update",
                    "view": loading_view,
                }
            )

        elif callback_id == "completion_reject_modal":
            values = view["state"]["values"]
            private_metadata = json.loads(view.get("private_metadata", "{}"))

            new_due_ts = values.get("new_due_block", {}).get("new_due_picker", {}).get("selected_date_time")
            reason = _get_text_input_value(values, "reason_block", "reason_input")

            if not new_due_ts:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {"new_due_block": "Êñ∞„Åó„ÅÑÁ¥çÊúü„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"},
                    }
                )

            if not reason:
                return JSONResponse(
                    content={
                        "response_action": "errors",
                        "errors": {"reason_block": "Âç¥‰∏ãÁêÜÁî±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"},
                    }
                )

            page_id = private_metadata.get("page_id")
            assignee_slack_id = private_metadata.get("assignee_slack_id")
            requester_slack_id = private_metadata.get("requester_slack_id") or payload.get("user", {}).get("id")
            new_due = datetime.fromtimestamp(new_due_ts, tz=timezone.utc).astimezone(JST)
            view_id = view.get("id")

            loading_view = {
                "type": "modal",
                "callback_id": "completion_reject_loading",
                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÂç¥‰∏ã"},
                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": "‚è≥ *ÂÆå‰∫ÜÁî≥Ë´ã„ÇíÂç¥‰∏ã„Åó„Å¶„ÅÑ„Åæ„Åô...*\nÊï∞Áßí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ"
                        }
                    }
                ]
            }

            import asyncio

            async def run_completion_rejection():
                try:
                    snapshot = await notion_service.get_task_snapshot(page_id)

                    await notion_service.reject_completion(page_id, new_due, reason)
                    await notion_service.record_audit_log(
                        task_page_id=page_id,
                        event_type="ÂÆå‰∫ÜÂç¥‰∏ã",
                        detail=f"Êñ∞„Åó„ÅÑÁ¥çÊúü: {_format_datetime_text(new_due)}\nÁêÜÁî±: {reason}",
                        actor_email=snapshot.requester_email if snapshot else None,
                    )

                    if snapshot:
                        await slack_service.notify_completion_rejected(
                            assignee_slack_id=assignee_slack_id,
                            requester_slack_id=requester_slack_id,
                            snapshot=snapshot,
                            reason=reason,
                            new_due=new_due,
                        )

                    if view_id:
                        try:
                            success_view = {
                                "type": "modal",
                                "callback_id": "completion_reject_success",
                                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÂç¥‰∏ã"},
                                "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
                                "blocks": [
                                    {
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": f"‚ö†Ô∏è *ÂÆå‰∫ÜÁî≥Ë´ã„ÇíÂç¥‰∏ã„Åó„Åæ„Åó„Åü*\nÊñ∞„Åó„ÅÑÁ¥çÊúü: {_format_datetime_text(new_due)}"
                                        }
                                    }
                                ]
                            }
                            slack_service.client.views_update(view_id=view_id, view=success_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ÂÆå‰∫ÜÂç¥‰∏ãÊàêÂäü„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

                except Exception as reject_error:
                    print(f"‚ö†Ô∏è Completion rejection failed: {reject_error}")
                    if view_id:
                        try:
                            error_view = {
                                "type": "modal",
                                "callback_id": "completion_reject_modal",
                                "title": {"type": "plain_text", "text": "ÂÆå‰∫ÜÂç¥‰∏ã"},
                                "submit": {"type": "plain_text", "text": "ÈÄÅ‰ø°"},
                                "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
                                "blocks": view.get("blocks", []),
                                "private_metadata": view.get("private_metadata", "{}"),
                            }
                            slack_service.client.views_update(view_id=view_id, view=error_view)
                        except Exception as update_error:
                            print(f"‚ö†Ô∏è ÂÆå‰∫ÜÂç¥‰∏ã„Ç®„É©„Éº„Éì„É•„Éº„ÅÆË°®Á§∫„Å´Â§±Êïó: {update_error}")

            asyncio.create_task(run_completion_rejection())

            return JSONResponse(
                content={
                    "response_action": "update",
                    "view": loading_view,
                }
            )

        else:
            print(f"‚ö†Ô∏è Unknown callback_id: {callback_id}")

    print(f"‚ö†Ô∏è Unhandled interaction_type: {interaction_type}")
    return JSONResponse(content={})


def _replace_actions_with_context(blocks: List[Dict[str, Any]], text: str) -> List[Dict[str, Any]]:
    updated_blocks: List[Dict[str, Any]] = []
    replaced = False
    for block in blocks:
        if not replaced and block.get("type") == "actions":
            updated_blocks.append({
                "type": "context",
                "elements": [
                    {
                        "type": "mrkdwn",
                        "text": text,
                    }
                ],
            })
            replaced = True
        else:
            updated_blocks.append(block)

    if not replaced:
        updated_blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": text,
                }
            ],
        })

    return updated_blocks


def _mark_read_update_blocks(blocks: List[Dict[str, Any]], text: str) -> List[Dict[str, Any]]:
    updated: List[Dict[str, Any]] = []
    context_added = False

    for block in blocks:
        if block.get("type") == "actions":
            elements = block.get("elements", [])
            remaining = [el for el in elements if el.get("action_id") != "mark_reminder_read"]

            if remaining:
                updated.append({**block, "elements": remaining})
            if not context_added:
                updated.append(
                    {
                        "type": "context",
                        "elements": [{"type": "mrkdwn", "text": text}],
                    }
                )
                context_added = True
        else:
            updated.append(block)

    if not context_added:
        updated.append(
            {
                "type": "context",
                "elements": [{"type": "mrkdwn", "text": text}],
            }
        )

    return updated


def _format_datetime_text(value: Optional[datetime]) -> str:
    if not value:
        return "-"
    if value.tzinfo:
        localized = value.astimezone(JST)
    else:
        localized = value.replace(tzinfo=JST)
    return localized.strftime("%Y-%m-%d %H:%M")


def _get_text_input_value(values: Dict[str, Any], block_id: str, action_id: str) -> str:
    block_state = values.get(block_id)
    if not isinstance(block_state, dict):
        return ""
    action_state = block_state.get(action_id)
    if not isinstance(action_state, dict):
        return ""
    value = action_state.get("value")
    if isinstance(value, str):
        return value.strip()
    return ""


def _to_utc(dt: Optional[datetime]) -> Optional[datetime]:
    if not dt:
        return None
    if dt.tzinfo:
        return dt.astimezone(timezone.utc)
    return dt.replace(tzinfo=JST).astimezone(timezone.utc)


def _requested_on_time(requested_at: Optional[datetime], due: Optional[datetime]) -> bool:
    req_utc = _to_utc(requested_at)
    due_utc = _to_utc(due)
    if not req_utc or not due_utc:
        return False
    return req_utc <= due_utc


def determine_reminder_stage(snapshot, reference_time: datetime) -> Optional[str]:
    """„É™„Éû„Ç§„É≥„ÉâÂØæË±°„Çπ„ÉÜ„Éº„Ç∏„ÇíÂà§ÂÆö"""
    task_status = getattr(snapshot, "status", None)
    if task_status == TASK_STATUS_PENDING:
        return REMINDER_STAGE_PENDING_APPROVAL

    if snapshot.completion_status in {COMPLETION_STATUS_REQUESTED, COMPLETION_STATUS_APPROVED}:
        return None

    due = getattr(snapshot, "due_date", None)
    if not due:
        return None

    due_value = due.astimezone(timezone.utc) if due.tzinfo else due.replace(tzinfo=timezone.utc)
    now_value = reference_time

    if snapshot.extension_status == EXTENSION_STATUS_PENDING:
        return None

    due_date_only = due_value.date()
    today = now_value.date()

    if due_date_only > today:
        hours_until_due = (due_value - now_value).total_seconds() / 3600
        if hours_until_due <= 24:
            return REMINDER_STAGE_BEFORE
        return None

    if due_date_only == today:
        if (due_value - now_value).total_seconds() >= 0:
            return REMINDER_STAGE_DUE
        return REMINDER_STAGE_OVERDUE

    return REMINDER_STAGE_OVERDUE


def _should_clear_overdue_points(snapshot, reference_time: datetime) -> bool:
    """Á¥çÊúüË∂ÖÈÅé„Éù„Ç§„É≥„Éà„Çí„ÇØ„É™„Ç¢„Åô„Åπ„Åç„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö"""
    due = getattr(snapshot, "due_date", None)
    due_utc = _to_utc(due)
    now_utc = _to_utc(reference_time)

    # Á¥çÊúü„ÅåÂ≠òÂú®„Åõ„Åö„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØÊú™Êù•„Å´ÂÜçË®≠ÂÆö„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„ÇØ„É™„Ç¢
    if not due_utc or (now_utc and due_utc > now_utc):
        return True

    # „Çø„Çπ„ÇØ„ÅåÊâøË™çÂæÖ„Å°„ÅÆ„Åæ„Åæ„Å™„Çâ„Éù„Ç§„É≥„Éà„ÅØ‰ªò‰∏é„Åó„Å™„ÅÑ
    if getattr(snapshot, "status", None) == TASK_STATUS_PENDING:
        return True

    completion_status = getattr(snapshot, "completion_status", None)
    if completion_status in {COMPLETION_STATUS_REQUESTED, COMPLETION_STATUS_APPROVED}:
        requested_at = getattr(snapshot, "completion_requested_at", None)
        if _requested_on_time(requested_at, due):
            return True

    return False


def _extract_plain_text_from_rich_text(rich_text: Dict[str, Any]) -> str:
    """„É™„ÉÉ„ÉÅ„ÉÜ„Ç≠„Çπ„Éà„Åã„Çâ„Éó„É¨„Éº„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫"""
    text_parts = []

    for element in rich_text.get("elements", []):
        for item in element.get("elements", []):
            if item.get("type") == "text":
                text_parts.append(item.get("text", ""))
            elif item.get("type") == "link":
                text_parts.append(item.get("url", ""))

    return "".join(text_parts)


async def handle_ai_enhancement(payload: dict, trigger_id: str) -> JSONResponse:
    """[Deprecated] ‰∫íÊèõÁî®: ÂêåÊúüÂá¶ÁêÜÁâàÔºàÊú™‰ΩøÁî®Ôºâ"""
    return JSONResponse(content={"response_action": "errors", "errors": {"ai_helper_section": "Deprecated handler"}}, status_code=200)


async def handle_ai_enhancement_async(payload: dict, trigger_id: str, view_id: Optional[str], user_id: str) -> JSONResponse:
    """AIË£úÂÆåÂá¶ÁêÜÔºàÈùûÂêåÊúüÂåñÔºâ: 3Áßí‰ª•ÂÜÖ„Å´ACK„Åó„Å¶Âá¶ÁêÜ‰∏≠Ë°®Á§∫ ‚Üí Âæå„Åßviews.update"""
    print(f"üöÄ handle_ai_enhancement_async ÈñãÂßã: user_id={user_id}, view_id={view_id}")
    try:
        print(f"üîç AI service check: ai_service={ai_service is not None}")
        if not ai_service:
            print("‚ùå AI service is None - GEMINI_API_KEY not configured")
            return JSONResponse(
                content={
                    "response_action": "errors",
                    "errors": {
                        "ai_helper_section": "AIÊ©üËÉΩ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇGEMINI_API_KEY„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    }
                },
                status_code=200
            )
        
        # ÁèæÂú®„ÅÆ„É¢„Éº„ÉÄ„É´„ÅÆÂÄ§„ÇíÂèñÂæó
        print("üîç „É¢„Éº„ÉÄ„É´ÂÄ§ÂèñÂæó‰∏≠...")
        view = payload.get("view", {})
        values = view.get("state", {}).get("values", {})
        print(f"üîç Values keys: {list(values.keys())}")
        
        # „Çø„Ç§„Éà„É´„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÂøÖÈ†àÊù°‰ª∂Ôºâ
        title = ""
        print("üîç „Çø„Ç§„Éà„É´ÂèñÂæó‰∏≠...")
        if "title_block" in values:
            title = values["title_block"].get("title_input", {}).get("value", "")
        print(f"üîç ÂèñÂæó„Åó„Åü„Çø„Ç§„Éà„É´: '{title}'")

        # title„ÅåNone„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
        if title is None:
            title = ""

        if not title.strip():
            print("‚ùå „Çø„Ç§„Éà„É´„ÅåÁ©∫„ÅÆ„Åü„ÇÅ„Ç®„É©„Éº„ÇíËøî„Åó„Åæ„Åô")
            return JSONResponse(
                content={
                    "response_action": "errors",
                    "errors": {
                        "title_block": "AIË£úÂÆå„Çí‰ΩøÁî®„Åô„Çã„Å´„ÅØ„ÄÅ„Åæ„Åö„Çø„Ç§„Éà„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    }
                },
                status_code=200
            )

        # ÁèæÂú®„ÅÆ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíÂèéÈõÜ
        print("üîç TaskInfo‰ΩúÊàê‰∏≠...")
        task_info = TaskInfo(title=title.strip())
        print(f"üîç TaskInfo‰ΩúÊàêÂÆå‰∫Ü: {task_info.title}")
        
        # „Çø„Çπ„ÇØÁ®ÆÈ°û
        if "task_type_block" in values:
            task_type_data = values["task_type_block"].get("task_type_select", {}).get("selected_option")
            if task_type_data:
                task_info.task_type = task_type_data["value"]
        
        # Á∑äÊÄ•Â∫¶
        if "urgency_block" in values:
            urgency_data = values["urgency_block"].get("urgency_select", {}).get("selected_option")
            if urgency_data:
                task_info.urgency = urgency_data["value"]
        
        # Á¥çÊúü
        if "due_date_block" in values:
            due_date_unix = values["due_date_block"].get("due_date_picker", {}).get("selected_date_time")
            if due_date_unix:
                due_date = datetime.fromtimestamp(due_date_unix, tz=timezone.utc).astimezone(JST)
                task_info.due_date = due_date.strftime('%YÂπ¥%mÊúà%dÊó• %H:%M')
        
        # ÁèæÂú®„ÅÆÂÜÖÂÆπ
        if "description_block" in values:
            current_desc = values["description_block"].get("description_input", {}).get("rich_text_value")
            if current_desc:
                task_info.current_description = convert_rich_text_to_plain_text(current_desc)
        
        # „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÅÆÁîüÊàê„Å®ÁÆ°ÁêÜ
        pm_raw = view.get("private_metadata")
        pm = {}
        try:
            pm = json.loads(pm_raw) if pm_raw else {}
        except Exception:
            pm = {}

        # AIË£úÂÆåÁî®„ÅÆ‰∏ÄÊÑè„Å™„Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÁîüÊàêÔºà„Éï„Ç©„Éº„É†ÂÖ•Âäõ‰∏≠„ÅÆ„ÅøÊúâÂäπÔºâ
        # „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÂê´„ÇÅ„Å¶‰∏ÄÊÑèÊÄß„ÇíÁ¢∫‰øù
        import time
        session_id = f"ai_session_{user_id}_{int(time.time() * 1000)}"
        print(f"üîç AIË£úÂÆå„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã: {session_id}")
        
        # ÁèæÂú®„ÅÆ„Éï„Ç©„Éº„É†ÂÄ§„ÇíÂÖ®„Å¶‰øùÂ≠ò
        current_values = {
            "assignee": None,
            "title": title,
            "due_date": None,
            "task_type": None,
            "urgency": None,
            "description": None
        }

        # ‰æùÈ†ºÂÖà
        if "assignee_block" in values:
            assignee_data = values["assignee_block"].get("assignee_select", {}).get("selected_option")
            if assignee_data:
                current_values["assignee"] = assignee_data

        # Á¥çÊúüÔºàUnix timestampÔºâ
        if "due_date_block" in values:
            due_date_unix = values["due_date_block"].get("due_date_picker", {}).get("selected_date_time")
            if due_date_unix:
                current_values["due_date"] = due_date_unix

        # „Çø„Çπ„ÇØÁ®ÆÈ°û
        if "task_type_block" in values:
            task_type_data = values["task_type_block"].get("task_type_select", {}).get("selected_option")
            if task_type_data:
                current_values["task_type"] = task_type_data

        # Á∑äÊÄ•Â∫¶
        if "urgency_block" in values:
            urgency_data = values["urgency_block"].get("urgency_select", {}).get("selected_option")
            if urgency_data:
                current_values["urgency"] = urgency_data

        # ÂÜÖÂÆπÔºà„É™„ÉÉ„ÉÅ„ÉÜ„Ç≠„Çπ„ÉàÔºâ
        if "description_block" in values:
            current_desc = values["description_block"].get("description_input", {}).get("rich_text_value")
            if current_desc:
                current_values["description"] = current_desc

        # „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±„Çí‰øùÂ≠òÔºàprivate_metadata„Çµ„Ç§„Ç∫Âà∂ÈôêÂØæÁ≠ñÔºâ
        requester_id = pm.get("requester_id")
        modal_sessions[session_id] = {
            "original_view": view,
            "current_values": current_values,
            "user_id": user_id,
            "trigger_id": trigger_id,
            "task_info": task_info,
            "view_id": view_id,
            "requester_id": requester_id,
        }

        # 1) „Åæ„ÅöÂç≥ÊôÇACKÔºàÂá¶ÁêÜ‰∏≠„Éì„É•„Éº„Å´ÁΩÆÊèõÔºâ
        print("üîç Âá¶ÁêÜ‰∏≠„Éì„É•„Éº‰ΩúÊàê‰∏≠...")
        processing_view = create_processing_view(session_id, title="AIË£úÂÆå - ÂÆüË°å‰∏≠", description="AI„ÅåÂÜÖÂÆπ„ÇíÊï¥ÁêÜ‰∏≠„Åß„Åô‚Ä¶ „Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ")
        print("‚úÖ Âá¶ÁêÜ‰∏≠„Éì„É•„Éº‰ΩúÊàêÂÆå‰∫Ü")

        # ÈùûÂêåÊúü„ÅßGeminiÂá¶ÁêÜ ‚Üí ÁµêÊûú„Å´Âøú„Åò„Å¶views.update
        import asyncio
        print("üîç ÈùûÂêåÊúüAIÂá¶ÁêÜÈñãÂßãÊ∫ñÂÇô‰∏≠...")

        async def run_analysis_and_update():
            try:
                print(f"ü§ñ AIÂàÜÊûêÂá¶ÁêÜÈñãÂßã: session_id={session_id}")
                # Êñ∞„Åó„ÅÑAIË£úÂÆå„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßãÔºàÂè§„ÅÑ‰ºöË©±Â±•Ê≠¥„Çí„ÇØ„É™„Ç¢Ôºâ
                print("üîç AIÂ±•Ê≠¥„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã‰∏≠...")
                ai_service.history.start_new_session(session_id)
                print("üîç AIÂàÜÊûêÂÆüË°å‰∏≠...")
                result = await ai_service.analyze_task_info(session_id, task_info)
                print(f"‚úÖ AIÂàÜÊûêÂÆå‰∫Ü: status={result.status}")
                if not view_id:
                    return
                if result.status == "insufficient_info":
                    new_view = create_additional_info_modal_view(session_id, result, requester_id)
                elif result.status == "ready_to_format":
                    modal_sessions[session_id]["generated_content"] = result.formatted_content
                    new_view = create_content_confirmation_modal_view(session_id, result, requester_id)
                else:
                    new_view = create_error_view(session_id, f"AIÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {result.message}")

                # private_metadata „Çí„Éû„Éº„Ç∏„Åó„Å¶‰ªò‰∏éÔºàrequester_idÁ∂≠ÊåÅ + session_idËøΩÂä†Ôºâ
                base_pm = {}
                try:
                    base_pm = json.loads(view.get("private_metadata", "{}"))
                except Exception:
                    base_pm = {}
                base_pm["session_id"] = session_id
                new_view["private_metadata"] = json.dumps(base_pm)
                slack_service.client.views_update(view_id=view_id, view=new_view)
            except Exception as e:
                err_view = create_error_view(session_id, f"AIÂá¶ÁêÜ„Ç®„É©„Éº: {str(e)}")
                try:
                    if view_id:
                        slack_service.client.views_update(view_id=view_id, view=err_view)
                except Exception:
                    pass

        print("üîç ÈùûÂêåÊúü„Çø„Çπ„ÇØ‰ΩúÊàê‰∏≠...")
        asyncio.create_task(run_analysis_and_update())
        print("‚úÖ ÈùûÂêåÊúü„Çø„Çπ„ÇØ‰ΩúÊàêÂÆå‰∫Ü")

        print("üîç Âá¶ÁêÜ‰∏≠„Éì„É•„Éº„ÇíËøîÂç¥‰∏≠...")
        return JSONResponse(content={"response_action": "update", "view": processing_view}, status_code=200)
            
    except Exception as e:
        error_msg = str(e)
        print(f"‚ùå AI enhancement error: {e}")
        
        # trigger_idÊúüÈôêÂàá„Çå„ÇÑÁâπÂÆö„ÅÆSlack API„Ç®„É©„Éº„ÅÆÂ†¥Âêà
        if any(keyword in error_msg.lower() for keyword in ["expired_trigger_id", "trigger_expired", "expired"]):
            return JSONResponse(
                content={
                    "response_action": "errors",
                    "errors": {
                        "ai_helper_section": "‚è∞ AIÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åô„Åé„Åæ„Åó„Åü„ÄÇÂá¶ÁêÜ„ÇíÈ´òÈÄüÂåñ„Åó„Å¶„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    }
                },
                status_code=200
            )
        
        return JSONResponse(
            content={
                "response_action": "errors",
                "errors": {
                    "ai_helper_section": f"AIÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {error_msg[:100]}..."
                }
            },
            status_code=200
        )


async def show_additional_info_modal(trigger_id: str, session_id: str, result: AIAnalysisResult, original_view: dict) -> JSONResponse:
    """[Deprecated] ÈùûÂêåÊúüÂåñ„Å´„Çà„ÇäÊú™‰ΩøÁî®„ÄÇviews.update „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"""
    return JSONResponse(content={}, status_code=200)


async def show_content_confirmation_modal(trigger_id: str, session_id: str, result: AIAnalysisResult, original_view: dict) -> JSONResponse:
    """[Deprecated] ÈùûÂêåÊúüÂåñ„Å´„Çà„ÇäÊú™‰ΩøÁî®„ÄÇviews.update „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"""
    return JSONResponse(content={}, status_code=200)


async def handle_additional_info_submission(payload: dict) -> JSONResponse:
    """ËøΩÂä†ÊÉÖÂ†±ÂÖ•Âäõ„É¢„Éº„ÉÄ„É´„ÅÆÈÄÅ‰ø°Âá¶ÁêÜÔºàÈùûÂêåÊúüÂåñ: Âç≥ÊôÇACK‚Üíviews.updateÔºâ"""
    try:
        if not ai_service:
            return JSONResponse(
                content={
                    "response_action": "errors",
                    "errors": {
                        "additional_info_block": "AIÊ©üËÉΩ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ"
                    }
                },
                status_code=200
            )
        
        view = payload.get("view", {})
        values = view.get("state", {}).get("values", {})
        view_id = view.get("id")
        private_metadata = json.loads(view.get("private_metadata", "{}"))
        session_id = private_metadata.get("session_id")
        session_data = modal_sessions.get(session_id, {})
        requester_id = session_data.get("requester_id")
        additional_info = values["additional_info_block"]["additional_info_input"].get("value", "")

        print(f"üîç ËøΩÂä†ÊÉÖÂ†±ÂÖ•Âäõ„Çª„ÉÉ„Ç∑„Éß„É≥: {session_id}, Â±•Ê≠¥Êï∞: {len(ai_service.history.get_conversation(session_id))}")

        if not additional_info.strip():
            return JSONResponse(
                content={
                    "response_action": "errors",
                    "errors": {
                        "additional_info_block": "ËøΩÂä†ÊÉÖÂ†±„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    }
                },
                status_code=200
            )

        # Âç≥ÊôÇACK: Âá¶ÁêÜ‰∏≠„Éì„É•„Éº
        processing_view = create_processing_view(session_id, title="AIË£úÂÆå - ÂÜçÂàÜÊûê‰∏≠", description="„ÅÑ„Åü„Å†„ÅÑ„ÅüÊÉÖÂ†±„ÅßÂÜçÂàÜÊûê„Åó„Å¶„ÅÑ„Åæ„Åô‚Ä¶")

        # ËÉåÊôØ„ÅßAIÊîπËâØ‚Üíviews.update
        import asyncio

        async def run_refine_and_update():
            try:
                result = await ai_service.refine_content(session_id, additional_info)
                if result.status == "insufficient_info":
                    new_view = create_additional_info_modal_view(session_id, result, requester_id)
                elif result.status == "ready_to_format":
                    modal_sessions[session_id]["generated_content"] = result.formatted_content
                    new_view = create_content_confirmation_modal_view(session_id, result, requester_id)
                else:
                    new_view = create_error_view(session_id, f"AIÂá¶ÁêÜ„Ç®„É©„Éº: {result.message}")
                # private_metadata „Çí„Éû„Éº„Ç∏Ôºàrequester_idÁ∂≠ÊåÅÔºâ
                pm = {"session_id": session_id}
                if requester_id:
                    pm["requester_id"] = requester_id
                new_view["private_metadata"] = json.dumps(pm)
                if view_id:
                    slack_service.client.views_update(view_id=view_id, view=new_view)
            except Exception as e:
                err_view = create_error_view(session_id, f"AIÂá¶ÁêÜ„Ç®„É©„Éº: {str(e)}")
                try:
                    if view_id:
                        slack_service.client.views_update(view_id=view_id, view=err_view)
                except Exception:
                    pass

        asyncio.create_task(run_refine_and_update())

        return JSONResponse(content={"response_action": "update", "view": processing_view}, status_code=200)
            
    except Exception as e:
        error_msg = str(e)
        print(f"‚ùå Additional info submission error: {e}")
        
        # API„Ç®„É©„Éº„Å´ÂØæ„Åô„ÇãÈÅ©Âàá„Å™„É°„ÉÉ„Çª„Éº„Ç∏
        if any(keyword in error_msg.lower() for keyword in ["timeout", "expired", "overloaded"]):
            error_text = "‚è∞ AIÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ"
        else:
            error_text = f"Âá¶ÁêÜ„Ç®„É©„Éº: {error_msg[:100]}..."
            
        return JSONResponse(
            content={
                "response_action": "errors",
                "errors": {
                    "additional_info_block": error_text
                }
            },
            status_code=200
        )


async def handle_content_confirmation(payload: dict) -> JSONResponse:
    """ÂÜÖÂÆπÁ¢∫Ë™ç„É¢„Éº„ÉÄ„É´„ÅÆÂá¶ÁêÜÔºàÈùûÂêåÊúüÂåñÔºâ"""
    try:
        view = payload.get("view", {})
        view_id = view.get("id")
        values = view.get("state", {}).get("values", {})
        private_metadata = json.loads(view.get("private_metadata", "{}"))
        
        session_id = private_metadata.get("session_id")
        session_data = modal_sessions.get(session_id, {})
        generated_content = session_data.get("generated_content")
        requester_id = session_data.get("requester_id")

        print(f"üîç ÂÜÖÂÆπÁ¢∫Ë™ç„Çª„ÉÉ„Ç∑„Éß„É≥: {session_id}, Â±•Ê≠¥Êï∞: {len(ai_service.history.get_conversation(session_id)) if ai_service else 0}")
        
        # „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        feedback = ""
        fb_block = values.get("feedback_block")
        if fb_block and "feedback_input" in fb_block:
            raw = fb_block["feedback_input"].get("value")
            feedback = (raw or "").strip()
        
        # Âç≥ÊôÇACK: Âá¶ÁêÜ‰∏≠„Éì„É•„Éº
        processing_view = create_processing_view(session_id, title="AIË£úÂÆå - ÂèçÊò†‰∏≠", description="ÂÜÖÂÆπ„ÇíÂèçÊò†„Åó„Å¶„ÅÑ„Åæ„Åô‚Ä¶")

        import asyncio

        async def run_feedback_apply():
            try:
                if feedback:
                    if not ai_service:
                        new_view = create_error_view(session_id, "AIÊ©üËÉΩ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ")
                    else:
                        result = await ai_service.refine_content(session_id, feedback)
                        if result.status == "insufficient_info":
                            # ËøΩÂä†Ë≥™Âïè„Å´Êàª„Åô
                            new_view = create_additional_info_modal_view(session_id, result, requester_id)
                        elif result.status == "ready_to_format":
                            modal_sessions.setdefault(session_id, {})
                            modal_sessions[session_id]["generated_content"] = result.formatted_content
                            new_view = create_content_confirmation_modal_view(session_id, result, requester_id)
                        else:
                            new_view = create_error_view(session_id, f"AIÂá¶ÁêÜ„Ç®„É©„Éº: {result.message}")
                else:
                    # „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Å™„Åó - ÂÖÉ„ÅÆ„É¢„Éº„ÉÄ„É´„Å´Êàª„Å£„Å¶ÂÜÖÂÆπ„ÇíÂèçÊò†
                    original_view = session_data.get("original_view")
                    current_values = session_data.get("current_values", {})

                    if original_view and generated_content:
                        # views.update„Å´ÂøÖË¶Å„Å™„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆ„Åø„ÇíÊäΩÂá∫
                        clean_view = {
                            "type": original_view.get("type", "modal"),
                            "callback_id": original_view.get("callback_id", "create_task_modal"),
                            "title": original_view.get("title"),
                            "submit": original_view.get("submit"),
                            "close": original_view.get("close"),
                            "blocks": original_view.get("blocks", [])
                        }

                        # ‰øùÂ≠ò„Åó„ÅüÂÄ§„ÇíÂêÑ„Éñ„É≠„ÉÉ„ÇØ„Å´Âæ©ÂÖÉ
                        if "blocks" in clean_view:
                            for block in clean_view["blocks"]:
                                block_id = block.get("block_id")

                                # ‰æùÈ†ºÂÖà
                                if block_id == "assignee_block" and current_values.get("assignee"):
                                    if "element" in block:
                                        block["element"]["initial_option"] = current_values["assignee"]

                                # „Çø„Ç§„Éà„É´
                                elif block_id == "title_block" and current_values.get("title"):
                                    if "element" in block:
                                        block["element"]["initial_value"] = current_values["title"]

                                # Á¥çÊúü
                                elif block_id == "due_date_block" and current_values.get("due_date"):
                                    if "element" in block:
                                        block["element"]["initial_date_time"] = current_values["due_date"]

                                # „Çø„Çπ„ÇØÁ®ÆÈ°û
                                elif block_id == "task_type_block" and current_values.get("task_type"):
                                    if "element" in block:
                                        block["element"]["initial_option"] = current_values["task_type"]

                                # Á∑äÊÄ•Â∫¶
                                elif block_id == "urgency_block" and current_values.get("urgency"):
                                    if "element" in block:
                                        block["element"]["initial_option"] = current_values["urgency"]

                                # ÂÜÖÂÆπË©≥Á¥∞ÔºàAIÁîüÊàêÂÜÖÂÆπ„ÇíË®≠ÂÆöÔºâ
                                elif block_id == "description_block":
                                    if "element" in block:
                                        block["element"]["initial_value"] = {
                                            "type": "rich_text",
                                            "elements": [
                                                {
                                                    "type": "rich_text_section",
                                                    "elements": [
                                                        {
                                                            "type": "text",
                                                            "text": generated_content
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                        new_view = clean_view
                    else:
                        new_view = create_error_view(session_id, "AIÁîüÊàêÂÜÖÂÆπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

                # private_metadata „Çí„Éû„Éº„Ç∏Ôºàrequester_idÁ∂≠ÊåÅÔºâ
                pm = {"session_id": session_id}
                if requester_id:
                    pm["requester_id"] = requester_id
                new_view["private_metadata"] = json.dumps(pm)
                if view_id:
                    slack_service.client.views_update(view_id=view_id, view=new_view)
            except Exception as e:
                try:
                    if view_id:
                        slack_service.client.views_update(view_id=view_id, view=create_error_view(session_id, f"Âá¶ÁêÜ„Ç®„É©„Éº: {str(e)}"))
                except Exception:
                    pass

        asyncio.create_task(run_feedback_apply())

        return JSONResponse(content={"response_action": "update", "view": processing_view}, status_code=200)
            
    except Exception as e:
        print(f"‚ùå Content confirmation error: {e}")
        return JSONResponse(
            content={
                "response_action": "errors",
                "errors": {
                    "feedback_block": f"Âá¶ÁêÜ„Ç®„É©„Éº: {str(e)}"
                }
            },
            status_code=200
        )


def create_additional_info_modal_view(session_id: str, result: AIAnalysisResult, requester_id: str = None) -> dict:
    """ËøΩÂä†ÊÉÖÂ†±„É¢„Éº„ÉÄ„É´„Éì„É•„Éº„Çí‰ΩúÊàê"""
    suggestions_text = "\n".join(f"‚Ä¢ {s}" for s in result.suggestions) if result.suggestions else ""

    # private_metadata„ÇíÊßãÁØâ
    pm = {"session_id": session_id}
    if requester_id:
        pm["requester_id"] = requester_id

    return {
        "type": "modal",
        "callback_id": "ai_additional_info_modal",
        "title": {
            "type": "plain_text",
            "text": "AIË£úÂÆå - ËøΩÂä†ÊÉÖÂ†±"
        },
        "submit": {
            "type": "plain_text",
            "text": "ÂàÜÊûêÂÆüË°å"
        },
        "close": {
            "type": "plain_text",
            "text": "„Ç≠„É£„É≥„Çª„É´"
        },
        "blocks": [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"ü§ñ *AIÂàÜÊûêÁµêÊûú*\n{result.message}"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*ÂøÖË¶Å„Å™ËøΩÂä†ÊÉÖÂ†±:*\n{suggestions_text}"
                }
            },
            {
                "type": "input",
                "block_id": "additional_info_block",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "additional_info_input",
                    "multiline": True,
                    "placeholder": {
                        "type": "plain_text",
                        "text": "‰∏äË®ò„ÅÆË≥™Âïè„Å´ÂØæ„Åô„ÇãÂõûÁ≠î„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ..."
                    }
                },
                "label": {
                    "type": "plain_text",
                    "text": "ËøΩÂä†ÊÉÖÂ†±"
                }
            }
        ],
        "private_metadata": json.dumps(pm)
    }


def create_content_confirmation_modal_view(session_id: str, result: AIAnalysisResult, requester_id: str = None) -> dict:
    """ÂÜÖÂÆπÁ¢∫Ë™ç„É¢„Éº„ÉÄ„É´„Éì„É•„Éº„Çí‰ΩúÊàê"""
    content_text = (result.formatted_content or result.message or "").strip()

    # private_metadata„ÇíÊßãÁØâ
    pm = {"session_id": session_id}
    if requester_id:
        pm["requester_id"] = requester_id

    return {
        "type": "modal",
        "callback_id": "ai_content_confirmation_modal",
        "title": {
            "type": "plain_text",
            "text": "AIË£úÂÆå - ÂÜÖÂÆπÁ¢∫Ë™ç"
        },
        "submit": {
            "type": "plain_text",
            "text": "Êé°Áî®„Åô„Çã"
        },
        "close": {
            "type": "plain_text",
            "text": "„Ç≠„É£„É≥„Çª„É´"
        },
        "blocks": [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "ü§ñ *AIÁîüÊàê„Åï„Çå„Åü„Çø„Çπ„ÇØÂÜÖÂÆπ*\n‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„Åß„Çà„Çç„Åó„Åë„Çå„Å∞„ÄåÊé°Áî®„Åô„Çã„Äç„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"```{content_text}```"
                }
            },
            {
                "type": "input",
                "block_id": "feedback_block",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "feedback_input",
                    "multiline": True,
                    "placeholder": {
                        "type": "plain_text",
                        "text": "‰øÆÊ≠£ÁÇπ„Åå„ÅÇ„Çå„Å∞ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà‰ªªÊÑèÔºâ"
                    }
                },
                "label": {
                    "type": "plain_text",
                    "text": "„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÔºà‰ªªÊÑèÔºâ"
                },
                "optional": True
            }
        ],
        "private_metadata": json.dumps(pm)
    }


def create_processing_view(session_id: str, title: str, description: str) -> dict:
    """Âá¶ÁêÜ‰∏≠„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº„Éì„É•„ÉºÔºàÂç≥ÊôÇACKÁî®Ôºâ"""
    return {
        "type": "modal",
        "callback_id": "ai_processing_modal",
        "title": {"type": "plain_text", "text": title[:24] or "Âá¶ÁêÜ‰∏≠"},
        "close": {"type": "plain_text", "text": "„Ç≠„É£„É≥„Çª„É´"},
        "blocks": [
            {"type": "section", "text": {"type": "mrkdwn", "text": f"‚è≥ {description}"}}
        ],
        "private_metadata": json.dumps({"session_id": session_id})
    }


def create_error_view(session_id: str, message: str) -> dict:
    """„Ç®„É©„Éº„Éì„É•„Éº"""
    return {
        "type": "modal",
        "callback_id": "ai_error_modal",
        "title": {"type": "plain_text", "text": "„Ç®„É©„Éº"},
        "close": {"type": "plain_text", "text": "Èñâ„Åò„Çã"},
        "blocks": [
            {"type": "section", "text": {"type": "mrkdwn", "text": f"‚ùå {message}"}}
        ],
        "private_metadata": json.dumps({"session_id": session_id})
    }


def _rebuild_task_form_blocks_with_values(values: dict, task_type: str, urgency: str) -> list:
    """„Ç®„É©„ÉºÊôÇ„Å´ÂÄ§„Çí‰øùÊåÅ„Åó„Åü„Çø„Çπ„ÇØ„Éï„Ç©„Éº„É†„Éñ„É≠„ÉÉ„ÇØ„ÇíÂÜçÊßãÁØâ"""
    
    # ‰æùÈ†ºÂÖà„ÅØÂÜçÈÅ∏Êäû„ÅåÂøÖË¶ÅÔºà„É¶„Éº„Ç∂„Éº„É™„Çπ„ÉàÂÜçÂèñÂæó„ÅåË§áÈõë„Å™„Åü„ÇÅÔºâ
    assignee_initial_option = None
    
    # „Çø„Ç§„Éà„É´„ÅÆÂàùÊúüÂÄ§
    title_initial_value = ""
    if "title_block" in values and "title_input" in values["title_block"]:
        title_initial_value = values["title_block"]["title_input"].get("value", "")
    
    # Á¥çÊúü„ÅÆÂàùÊúüÂÄ§
    due_date_initial = None
    if "due_date_block" in values and "due_date_picker" in values["due_date_block"]:
        due_date_initial = values["due_date_block"]["due_date_picker"].get("selected_date_time")
    
    # ÂÜÖÂÆπË©≥Á¥∞„ÅÆÂàùÊúüÂÄ§
    description_initial = None
    if "description_block" in values and "description_input" in values["description_block"]:
        description_rich = values["description_block"]["description_input"].get("rich_text_value")
        if description_rich:
            description_initial = description_rich

    blocks = [
        {
            "type": "input",
            "block_id": "assignee_block",
            "element": {
                "type": "static_select",
                "placeholder": {"type": "plain_text", "text": "‰æùÈ†ºÂÖà„ÇíÂÜçÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"},
                "options": [{"text": {"type": "plain_text", "text": "„É¶„Éº„Ç∂„Éº„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠..."}, "value": "loading"}],
                "action_id": "assignee_select",
            },
            "label": {"type": "plain_text", "text": "‰æùÈ†ºÂÖà"},
        },
        {
            "type": "input",
            "block_id": "title_block",
            "element": {
                "type": "plain_text_input",
                "action_id": "title_input",
                "placeholder": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ„ÅÆ‰ª∂Âêç„ÇíÂÖ•Âäõ"},
            },
            "label": {"type": "plain_text", "text": "‰ª∂Âêç"},
        },
        {
            "type": "input",
            "block_id": "due_date_block",
            "element": {
                "type": "datetimepicker",
                "action_id": "due_date_picker"
            },
            "label": {"type": "plain_text", "text": "Á¥çÊúü"},
        },
        {
            "type": "input",
            "block_id": "task_type_block",
            "element": {
                "type": "static_select",
                "placeholder": {"type": "plain_text", "text": "„Çø„Çπ„ÇØÁ®ÆÈ°û„ÇíÈÅ∏Êäû"},
                "options": [
                    {"text": {"type": "plain_text", "text": "„Éï„É™„Éº„É©„É≥„ÇπÈñ¢‰øÇ"}, "value": "„Éï„É™„Éº„É©„É≥„ÇπÈñ¢‰øÇ"},
                    {"text": {"type": "plain_text", "text": "„É¢„Éé„ÉÜ„ÉÉ„ÇØÈñ¢ÈÄ£"}, "value": "„É¢„Éé„ÉÜ„ÉÉ„ÇØÈñ¢ÈÄ£"},
                    {"text": {"type": "plain_text", "text": "Á§æÂÜÖ„Çø„Çπ„ÇØ"}, "value": "Á§æÂÜÖ„Çø„Çπ„ÇØ"},
                    {"text": {"type": "plain_text", "text": "HHÈñ¢ÈÄ£"}, "value": "HHÈñ¢ÈÄ£"},
                    {"text": {"type": "plain_text", "text": "SalesÈñ¢ÈÄ£"}, "value": "SalesÈñ¢ÈÄ£"},
                    {"text": {"type": "plain_text", "text": "PLÈñ¢ÈÄ£"}, "value": "PLÈñ¢ÈÄ£"},
                ],
                "action_id": "task_type_select",
            },
            "label": {"type": "plain_text", "text": "„Çø„Çπ„ÇØÁ®ÆÈ°û"},
        },
        {
            "type": "input",
            "block_id": "urgency_block",
            "element": {
                "type": "static_select",
                "placeholder": {"type": "plain_text", "text": "Á∑äÊÄ•Â∫¶„ÇíÈÅ∏Êäû"},
                "options": [
                    {"text": {"type": "plain_text", "text": "„Éé„É≥„Ç≥„Ç¢Á§æÂÜÖ„Çø„Çπ„ÇØ"}, "value": "„Éé„É≥„Ç≥„Ç¢Á§æÂÜÖ„Çø„Çπ„ÇØ"},
                    {"text": {"type": "plain_text", "text": "1ÈÄ±Èñì‰ª•ÂÜÖ"}, "value": "1ÈÄ±Èñì‰ª•ÂÜÖ"},
                    {"text": {"type": "plain_text", "text": "ÊúÄÈáçË¶Å"}, "value": "ÊúÄÈáçË¶Å"},
                ],
                "action_id": "urgency_select",
            },
            "label": {"type": "plain_text", "text": "Á∑äÊÄ•Â∫¶"},
        },
        {
            "type": "section",
            "block_id": "ai_helper_section",
            "text": {"type": "mrkdwn", "text": "ü§ñ *AIË£úÂÆåÊ©üËÉΩ*\n„Çø„Çπ„ÇØ„ÅÆË©≥Á¥∞ÂÜÖÂÆπ„ÇíAI„Å´ÁîüÊàê„ÉªÊîπËâØ„Åó„Å¶„ÇÇ„Çâ„Åà„Åæ„Åô"},
            "accessory": {
                "type": "button",
                "text": {"type": "plain_text", "text": "AIË£úÂÆå", "emoji": True},
                "value": "ai_enhance",
                "action_id": "ai_enhance_button",
            },
        },
        {
            "type": "input",
            "block_id": "description_block",
            "element": {
                "type": "rich_text_input",
                "action_id": "description_input",
                "placeholder": {"type": "plain_text", "text": "„Çø„Çπ„ÇØ„ÅÆË©≥Á¥∞„ÇíÂÖ•ÂäõÔºà‰ªªÊÑèÔºâ"},
            },
            "label": {"type": "plain_text", "text": "ÂÜÖÂÆπË©≥Á¥∞"},
            "optional": True,
        },
    ]
    
    # ÂàùÊúüÂÄ§„ÇíË®≠ÂÆö
    if assignee_initial_option:
        blocks[0]["element"]["initial_option"] = assignee_initial_option
    if title_initial_value:
        blocks[1]["element"]["initial_value"] = title_initial_value
    if due_date_initial:
        blocks[2]["element"]["initial_date_time"] = due_date_initial
    if task_type:
        blocks[3]["element"]["initial_option"] = {"text": {"type": "plain_text", "text": task_type}, "value": task_type}
    if urgency:
        blocks[4]["element"]["initial_option"] = {"text": {"type": "plain_text", "text": urgency}, "value": urgency}
    if description_initial:
        blocks[7]["element"]["initial_value"] = description_initial
    
    return blocks
